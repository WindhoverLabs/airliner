//
// ex: set ro:
// DO NOT EDIT.
// generated by smc (http://smc.sourceforge.net/)
// from file : Arming.sm
//

#ifndef ARMINGCONTEXT_H
#define ARMINGCONTEXT_H


#define SMC_USES_IOSTREAMS

#include <statemap.h>

// Forward declarations.
class ArmingMap;
class ArmingMap_Init;
class ArmingMap_Standby;
class ArmingMap_Armed;
class ArmingMap_StandbyError;
class ArmingMap_ArmedError;
class ArmingMap_Default;
class ArmingState;
class ArmingContext;
class Arming;

class ArmingState :
    public statemap::State
{
public:

    ArmingState(const char * const name, const int stateId)
    : statemap::State(name, stateId)
    {};

    virtual void Entry(ArmingContext&) {};
    virtual void Exit(ArmingContext&) {};

    virtual void evArm(ArmingContext& context);
    virtual void evDisarm(ArmingContext& context);
    virtual void evError(ArmingContext& context);
    virtual void evInitComplete(ArmingContext& context);

protected:

    virtual void Default(ArmingContext& context);
};

class ArmingMap
{
public:

    static ArmingMap_Init Init;
    static ArmingMap_Standby Standby;
    static ArmingMap_Armed Armed;
    static ArmingMap_StandbyError StandbyError;
    static ArmingMap_ArmedError ArmedError;
};

class ArmingMap_Default :
    public ArmingState
{
public:

    ArmingMap_Default(const char * const name, const int stateId)
    : ArmingState(name, stateId)
    {};

};

class ArmingMap_Init :
    public ArmingMap_Default
{
public:
    ArmingMap_Init(const char * const name, const int stateId)
    : ArmingMap_Default(name, stateId)
    {};

    virtual void evInitComplete(ArmingContext& context);
};

class ArmingMap_Standby :
    public ArmingMap_Default
{
public:
    ArmingMap_Standby(const char * const name, const int stateId)
    : ArmingMap_Default(name, stateId)
    {};

    virtual void evArm(ArmingContext& context);
    virtual void evError(ArmingContext& context);
};

class ArmingMap_Armed :
    public ArmingMap_Default
{
public:
    ArmingMap_Armed(const char * const name, const int stateId)
    : ArmingMap_Default(name, stateId)
    {};

    virtual void evDisarm(ArmingContext& context);
    virtual void evError(ArmingContext& context);
};

class ArmingMap_StandbyError :
    public ArmingMap_Default
{
public:
    ArmingMap_StandbyError(const char * const name, const int stateId)
    : ArmingMap_Default(name, stateId)
    {};

};

class ArmingMap_ArmedError :
    public ArmingMap_Default
{
public:
    ArmingMap_ArmedError(const char * const name, const int stateId)
    : ArmingMap_Default(name, stateId)
    {};

};

class ArmingContext :
    public statemap::FSMContext
{
public:

    explicit ArmingContext(Arming& owner)
    : FSMContext(ArmingMap::Init),
      _owner(owner)
    {};

    ArmingContext(Arming& owner, const statemap::State& state)
    : FSMContext(state),
      _owner(owner)
    {};

    virtual void enterStartState()
    {
        getState().Entry(*this);
        return;
    }

    inline Arming& getOwner()
    {
        return (_owner);
    };

    inline ArmingState& getState()
    {
        if (_state == NULL)
        {
            throw statemap::StateUndefinedException();
        }

        return dynamic_cast<ArmingState&>(*_state);
    };

    inline void evArm()
    {
        getState().evArm(*this);
    };

    inline void evDisarm()
    {
        getState().evDisarm(*this);
    };

    inline void evError()
    {
        getState().evError(*this);
    };

    inline void evInitComplete()
    {
        getState().evInitComplete(*this);
    };

private:
    Arming& _owner;
};


#endif // ARMINGCONTEXT_H

//
// Local variables:
//  buffer-read-only: t
// End:
//
