/* This file was autogenerated from template version 0.0.0.2 and autogenerator version 0.0.0.1 */

#include "px4_serialization.h"

#ifdef __cplusplus
extern "C" {
#endif

uint32 PX4_DistanceSensorMsg_t_Enc(const PX4_DistanceSensorMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_DistanceSensorMsg_t_pb pbMsg;

    pbMsg.Type = inObject->Type;
    pbMsg.Orientation = inObject->Orientation;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Covariance = inObject->Covariance;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.MinDistance = inObject->MinDistance;
    pbMsg.CurrentDistance = inObject->CurrentDistance;
    pbMsg.MaxDistance = inObject->MaxDistance;
    pbMsg.ID = inObject->ID;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_DistanceSensorMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_DistanceSensorMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_DistanceSensorMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_DistanceSensorMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_DistanceSensorMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Type = pbMsg.Type;
    inOutObject->Orientation = pbMsg.Orientation;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Covariance = pbMsg.Covariance;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->MinDistance = pbMsg.MinDistance;
    inOutObject->CurrentDistance = pbMsg.CurrentDistance;
    inOutObject->MaxDistance = pbMsg.MaxDistance;
    inOutObject->ID = pbMsg.ID;

	return sizeof(PX4_DistanceSensorMsg_t);
}


uint32 PX4_VehicleGlobalPositionMsg_t_Enc(const PX4_VehicleGlobalPositionMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleGlobalPositionMsg_t_pb pbMsg;

    pbMsg.VelN = inObject->VelN;
    pbMsg.DeadReckoning = inObject->DeadReckoning;
    pbMsg.Yaw = inObject->Yaw;
    pbMsg.Lon = inObject->Lon;
    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.DeltaLatLon_count = 2;
    pbMsg.DeltaLatLon[0] = inObject->DeltaLatLon[0];
    pbMsg.DeltaLatLon[1] = inObject->DeltaLatLon[1];
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.TerrainAltValid = inObject->TerrainAltValid;
    pbMsg.Lat = inObject->Lat;
    pbMsg.AltResetCounter = inObject->AltResetCounter;
    pbMsg.DeltaAlt = inObject->DeltaAlt;
    pbMsg.TimeUtcUsec = inObject->TimeUtcUsec;
    pbMsg.PressureAlt = inObject->PressureAlt;
    pbMsg.VelE = inObject->VelE;
    pbMsg.VelD = inObject->VelD;
    pbMsg.Alt = inObject->Alt;
    pbMsg.EvH = inObject->EvH;
    pbMsg.EpV = inObject->EpV;
    pbMsg.LatLonResetCounter = inObject->LatLonResetCounter;
    pbMsg.EpH = inObject->EpH;
    pbMsg.TerrainAlt = inObject->TerrainAlt;
    pbMsg.EvV = inObject->EvV;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleGlobalPositionMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleGlobalPositionMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleGlobalPositionMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleGlobalPositionMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleGlobalPositionMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->VelN = pbMsg.VelN;
    inOutObject->DeadReckoning = pbMsg.DeadReckoning;
    inOutObject->Yaw = pbMsg.Yaw;
    inOutObject->Lon = pbMsg.Lon;
    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->DeltaLatLon[0] = pbMsg.DeltaLatLon[0];
    inOutObject->DeltaLatLon[1] = pbMsg.DeltaLatLon[1];
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->TerrainAltValid = pbMsg.TerrainAltValid;
    inOutObject->Lat = pbMsg.Lat;
    inOutObject->AltResetCounter = pbMsg.AltResetCounter;
    inOutObject->DeltaAlt = pbMsg.DeltaAlt;
    inOutObject->TimeUtcUsec = pbMsg.TimeUtcUsec;
    inOutObject->PressureAlt = pbMsg.PressureAlt;
    inOutObject->VelE = pbMsg.VelE;
    inOutObject->VelD = pbMsg.VelD;
    inOutObject->Alt = pbMsg.Alt;
    inOutObject->EvH = pbMsg.EvH;
    inOutObject->EpV = pbMsg.EpV;
    inOutObject->LatLonResetCounter = pbMsg.LatLonResetCounter;
    inOutObject->EpH = pbMsg.EpH;
    inOutObject->TerrainAlt = pbMsg.TerrainAlt;
    inOutObject->EvV = pbMsg.EvV;

	return sizeof(PX4_VehicleGlobalPositionMsg_t);
}


uint32 PX4_SensorCombinedMsg_t_Enc(const PX4_SensorCombinedMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SensorCombinedMsg_t_pb pbMsg;

    /* Unroll indexes */
    pbMsg.Acc_count = 3;
    pbMsg.Acc[0] = inObject->Acc[0];
    pbMsg.Acc[1] = inObject->Acc[1];
    pbMsg.Acc[2] = inObject->Acc[2];
    pbMsg.MagTimestampRelative = inObject->MagTimestampRelative;
    pbMsg.AccRelTimeInvalid = inObject->AccRelTimeInvalid;
    pbMsg.GyroIntegralDt = inObject->GyroIntegralDt;
    pbMsg.AccTimestampRelative = inObject->AccTimestampRelative;
    pbMsg.BaroRelTimeInvalid = inObject->BaroRelTimeInvalid;
    pbMsg.AccIntegralDt = inObject->AccIntegralDt;
    pbMsg.BaroAlt = inObject->BaroAlt;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    /* Unroll indexes */
    pbMsg.Mag_count = 3;
    pbMsg.Mag[0] = inObject->Mag[0];
    pbMsg.Mag[1] = inObject->Mag[1];
    pbMsg.Mag[2] = inObject->Mag[2];
    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.GyroRad_count = 3;
    pbMsg.GyroRad[0] = inObject->GyroRad[0];
    pbMsg.GyroRad[1] = inObject->GyroRad[1];
    pbMsg.GyroRad[2] = inObject->GyroRad[2];
    pbMsg.MagRelTimeInvalid = inObject->MagRelTimeInvalid;
    pbMsg.BaroTemp = inObject->BaroTemp;
    pbMsg.BaroTimestampRelative = inObject->BaroTimestampRelative;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SensorCombinedMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SensorCombinedMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SensorCombinedMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SensorCombinedMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SensorCombinedMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    /* Unroll indexes */
    inOutObject->Acc[0] = pbMsg.Acc[0];
    inOutObject->Acc[1] = pbMsg.Acc[1];
    inOutObject->Acc[2] = pbMsg.Acc[2];
    inOutObject->MagTimestampRelative = pbMsg.MagTimestampRelative;
    inOutObject->AccRelTimeInvalid = pbMsg.AccRelTimeInvalid;
    inOutObject->GyroIntegralDt = pbMsg.GyroIntegralDt;
    inOutObject->AccTimestampRelative = pbMsg.AccTimestampRelative;
    inOutObject->BaroRelTimeInvalid = pbMsg.BaroRelTimeInvalid;
    inOutObject->AccIntegralDt = pbMsg.AccIntegralDt;
    inOutObject->BaroAlt = pbMsg.BaroAlt;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    /* Unroll indexes */
    inOutObject->Mag[0] = pbMsg.Mag[0];
    inOutObject->Mag[1] = pbMsg.Mag[1];
    inOutObject->Mag[2] = pbMsg.Mag[2];
    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->GyroRad[0] = pbMsg.GyroRad[0];
    inOutObject->GyroRad[1] = pbMsg.GyroRad[1];
    inOutObject->GyroRad[2] = pbMsg.GyroRad[2];
    inOutObject->MagRelTimeInvalid = pbMsg.MagRelTimeInvalid;
    inOutObject->BaroTemp = pbMsg.BaroTemp;
    inOutObject->BaroTimestampRelative = pbMsg.BaroTimestampRelative;

	return sizeof(PX4_SensorCombinedMsg_t);
}


uint32 PX4_EstimatorStatusMsg_t_Enc(const PX4_EstimatorStatusMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_EstimatorStatusMsg_t_pb pbMsg;

    pbMsg.GpsCheckFailFlags = inObject->GpsCheckFailFlags;
    pbMsg.NanFlags = inObject->NanFlags;
    /* Unroll indexes */
    pbMsg.Vibe_count = 3;
    pbMsg.Vibe[0] = inObject->Vibe[0];
    pbMsg.Vibe[1] = inObject->Vibe[1];
    pbMsg.Vibe[2] = inObject->Vibe[2];
    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.Covariances_count = 28;
    pbMsg.Covariances[0] = inObject->Covariances[0];
    pbMsg.Covariances[1] = inObject->Covariances[1];
    pbMsg.Covariances[2] = inObject->Covariances[2];
    pbMsg.Covariances[3] = inObject->Covariances[3];
    pbMsg.Covariances[4] = inObject->Covariances[4];
    pbMsg.Covariances[5] = inObject->Covariances[5];
    pbMsg.Covariances[6] = inObject->Covariances[6];
    pbMsg.Covariances[7] = inObject->Covariances[7];
    pbMsg.Covariances[8] = inObject->Covariances[8];
    pbMsg.Covariances[9] = inObject->Covariances[9];
    pbMsg.Covariances[10] = inObject->Covariances[10];
    pbMsg.Covariances[11] = inObject->Covariances[11];
    pbMsg.Covariances[12] = inObject->Covariances[12];
    pbMsg.Covariances[13] = inObject->Covariances[13];
    pbMsg.Covariances[14] = inObject->Covariances[14];
    pbMsg.Covariances[15] = inObject->Covariances[15];
    pbMsg.Covariances[16] = inObject->Covariances[16];
    pbMsg.Covariances[17] = inObject->Covariances[17];
    pbMsg.Covariances[18] = inObject->Covariances[18];
    pbMsg.Covariances[19] = inObject->Covariances[19];
    pbMsg.Covariances[20] = inObject->Covariances[20];
    pbMsg.Covariances[21] = inObject->Covariances[21];
    pbMsg.Covariances[22] = inObject->Covariances[22];
    pbMsg.Covariances[23] = inObject->Covariances[23];
    pbMsg.Covariances[24] = inObject->Covariances[24];
    pbMsg.Covariances[25] = inObject->Covariances[25];
    pbMsg.Covariances[26] = inObject->Covariances[26];
    pbMsg.Covariances[27] = inObject->Covariances[27];
    pbMsg.NumStates = inObject->NumStates;
    /* Unroll indexes */
    pbMsg.States_count = 32;
    pbMsg.States[0] = inObject->States[0];
    pbMsg.States[1] = inObject->States[1];
    pbMsg.States[2] = inObject->States[2];
    pbMsg.States[3] = inObject->States[3];
    pbMsg.States[4] = inObject->States[4];
    pbMsg.States[5] = inObject->States[5];
    pbMsg.States[6] = inObject->States[6];
    pbMsg.States[7] = inObject->States[7];
    pbMsg.States[8] = inObject->States[8];
    pbMsg.States[9] = inObject->States[9];
    pbMsg.States[10] = inObject->States[10];
    pbMsg.States[11] = inObject->States[11];
    pbMsg.States[12] = inObject->States[12];
    pbMsg.States[13] = inObject->States[13];
    pbMsg.States[14] = inObject->States[14];
    pbMsg.States[15] = inObject->States[15];
    pbMsg.States[16] = inObject->States[16];
    pbMsg.States[17] = inObject->States[17];
    pbMsg.States[18] = inObject->States[18];
    pbMsg.States[19] = inObject->States[19];
    pbMsg.States[20] = inObject->States[20];
    pbMsg.States[21] = inObject->States[21];
    pbMsg.States[22] = inObject->States[22];
    pbMsg.States[23] = inObject->States[23];
    pbMsg.States[24] = inObject->States[24];
    pbMsg.States[25] = inObject->States[25];
    pbMsg.States[26] = inObject->States[26];
    pbMsg.States[27] = inObject->States[27];
    pbMsg.States[28] = inObject->States[28];
    pbMsg.States[29] = inObject->States[29];
    pbMsg.States[30] = inObject->States[30];
    pbMsg.States[31] = inObject->States[31];
    pbMsg.HealthFlags = inObject->HealthFlags;
    pbMsg.TimeoutFlags = inObject->TimeoutFlags;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.FilterFaultFlags = inObject->FilterFaultFlags;
    pbMsg.ControlModeFlags = inObject->ControlModeFlags;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_EstimatorStatusMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_EstimatorStatusMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_EstimatorStatusMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_EstimatorStatusMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_EstimatorStatusMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->GpsCheckFailFlags = pbMsg.GpsCheckFailFlags;
    inOutObject->NanFlags = pbMsg.NanFlags;
    /* Unroll indexes */
    inOutObject->Vibe[0] = pbMsg.Vibe[0];
    inOutObject->Vibe[1] = pbMsg.Vibe[1];
    inOutObject->Vibe[2] = pbMsg.Vibe[2];
    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->Covariances[0] = pbMsg.Covariances[0];
    inOutObject->Covariances[1] = pbMsg.Covariances[1];
    inOutObject->Covariances[2] = pbMsg.Covariances[2];
    inOutObject->Covariances[3] = pbMsg.Covariances[3];
    inOutObject->Covariances[4] = pbMsg.Covariances[4];
    inOutObject->Covariances[5] = pbMsg.Covariances[5];
    inOutObject->Covariances[6] = pbMsg.Covariances[6];
    inOutObject->Covariances[7] = pbMsg.Covariances[7];
    inOutObject->Covariances[8] = pbMsg.Covariances[8];
    inOutObject->Covariances[9] = pbMsg.Covariances[9];
    inOutObject->Covariances[10] = pbMsg.Covariances[10];
    inOutObject->Covariances[11] = pbMsg.Covariances[11];
    inOutObject->Covariances[12] = pbMsg.Covariances[12];
    inOutObject->Covariances[13] = pbMsg.Covariances[13];
    inOutObject->Covariances[14] = pbMsg.Covariances[14];
    inOutObject->Covariances[15] = pbMsg.Covariances[15];
    inOutObject->Covariances[16] = pbMsg.Covariances[16];
    inOutObject->Covariances[17] = pbMsg.Covariances[17];
    inOutObject->Covariances[18] = pbMsg.Covariances[18];
    inOutObject->Covariances[19] = pbMsg.Covariances[19];
    inOutObject->Covariances[20] = pbMsg.Covariances[20];
    inOutObject->Covariances[21] = pbMsg.Covariances[21];
    inOutObject->Covariances[22] = pbMsg.Covariances[22];
    inOutObject->Covariances[23] = pbMsg.Covariances[23];
    inOutObject->Covariances[24] = pbMsg.Covariances[24];
    inOutObject->Covariances[25] = pbMsg.Covariances[25];
    inOutObject->Covariances[26] = pbMsg.Covariances[26];
    inOutObject->Covariances[27] = pbMsg.Covariances[27];
    inOutObject->NumStates = pbMsg.NumStates;
    /* Unroll indexes */
    inOutObject->States[0] = pbMsg.States[0];
    inOutObject->States[1] = pbMsg.States[1];
    inOutObject->States[2] = pbMsg.States[2];
    inOutObject->States[3] = pbMsg.States[3];
    inOutObject->States[4] = pbMsg.States[4];
    inOutObject->States[5] = pbMsg.States[5];
    inOutObject->States[6] = pbMsg.States[6];
    inOutObject->States[7] = pbMsg.States[7];
    inOutObject->States[8] = pbMsg.States[8];
    inOutObject->States[9] = pbMsg.States[9];
    inOutObject->States[10] = pbMsg.States[10];
    inOutObject->States[11] = pbMsg.States[11];
    inOutObject->States[12] = pbMsg.States[12];
    inOutObject->States[13] = pbMsg.States[13];
    inOutObject->States[14] = pbMsg.States[14];
    inOutObject->States[15] = pbMsg.States[15];
    inOutObject->States[16] = pbMsg.States[16];
    inOutObject->States[17] = pbMsg.States[17];
    inOutObject->States[18] = pbMsg.States[18];
    inOutObject->States[19] = pbMsg.States[19];
    inOutObject->States[20] = pbMsg.States[20];
    inOutObject->States[21] = pbMsg.States[21];
    inOutObject->States[22] = pbMsg.States[22];
    inOutObject->States[23] = pbMsg.States[23];
    inOutObject->States[24] = pbMsg.States[24];
    inOutObject->States[25] = pbMsg.States[25];
    inOutObject->States[26] = pbMsg.States[26];
    inOutObject->States[27] = pbMsg.States[27];
    inOutObject->States[28] = pbMsg.States[28];
    inOutObject->States[29] = pbMsg.States[29];
    inOutObject->States[30] = pbMsg.States[30];
    inOutObject->States[31] = pbMsg.States[31];
    inOutObject->HealthFlags = pbMsg.HealthFlags;
    inOutObject->TimeoutFlags = pbMsg.TimeoutFlags;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->FilterFaultFlags = pbMsg.FilterFaultFlags;
    inOutObject->ControlModeFlags = pbMsg.ControlModeFlags;

	return sizeof(PX4_EstimatorStatusMsg_t);
}



uint32 PX4_McAttCtrlStatusMsg_t_Enc(const PX4_McAttCtrlStatusMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_McAttCtrlStatusMsg_t_pb pbMsg;

    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.PitchRateInteg = inObject->PitchRateInteg;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.YawRateInteg = inObject->YawRateInteg;
    pbMsg.RollRateInteg = inObject->RollRateInteg;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_McAttCtrlStatusMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_McAttCtrlStatusMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_McAttCtrlStatusMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_McAttCtrlStatusMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_McAttCtrlStatusMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->PitchRateInteg = pbMsg.PitchRateInteg;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->YawRateInteg = pbMsg.YawRateInteg;
    inOutObject->RollRateInteg = pbMsg.RollRateInteg;

	return sizeof(PX4_McAttCtrlStatusMsg_t);
}


uint32 PX4_InputRcMsg_t_Enc(const PX4_InputRcMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_InputRcMsg_t_pb pbMsg;

    pbMsg.RcTotalFrameCount = inObject->RcTotalFrameCount;
    pbMsg.RcLost = inObject->RcLost;
    pbMsg.ChannelCount = inObject->ChannelCount;
    pbMsg.LastSignal = inObject->LastSignal;
    pbMsg.RcFailsafe = inObject->RcFailsafe;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.InputSource = inObject->InputSource;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    /* Unroll indexes */
    pbMsg.Values_count = 18;
    pbMsg.Values[0] = inObject->Values[0];
    pbMsg.Values[1] = inObject->Values[1];
    pbMsg.Values[2] = inObject->Values[2];
    pbMsg.Values[3] = inObject->Values[3];
    pbMsg.Values[4] = inObject->Values[4];
    pbMsg.Values[5] = inObject->Values[5];
    pbMsg.Values[6] = inObject->Values[6];
    pbMsg.Values[7] = inObject->Values[7];
    pbMsg.Values[8] = inObject->Values[8];
    pbMsg.Values[9] = inObject->Values[9];
    pbMsg.Values[10] = inObject->Values[10];
    pbMsg.Values[11] = inObject->Values[11];
    pbMsg.Values[12] = inObject->Values[12];
    pbMsg.Values[13] = inObject->Values[13];
    pbMsg.Values[14] = inObject->Values[14];
    pbMsg.Values[15] = inObject->Values[15];
    pbMsg.Values[16] = inObject->Values[16];
    pbMsg.Values[17] = inObject->Values[17];
    pbMsg.RcPpmFrameLength = inObject->RcPpmFrameLength;
    pbMsg.RcLostFrameCount = inObject->RcLostFrameCount;
    pbMsg.RSSI = inObject->RSSI;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_InputRcMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_InputRcMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_InputRcMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_InputRcMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_InputRcMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->RcTotalFrameCount = pbMsg.RcTotalFrameCount;
    inOutObject->RcLost = pbMsg.RcLost;
    inOutObject->ChannelCount = pbMsg.ChannelCount;
    inOutObject->LastSignal = pbMsg.LastSignal;
    inOutObject->RcFailsafe = pbMsg.RcFailsafe;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->InputSource = pbMsg.InputSource;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    /* Unroll indexes */
    inOutObject->Values[0] = pbMsg.Values[0];
    inOutObject->Values[1] = pbMsg.Values[1];
    inOutObject->Values[2] = pbMsg.Values[2];
    inOutObject->Values[3] = pbMsg.Values[3];
    inOutObject->Values[4] = pbMsg.Values[4];
    inOutObject->Values[5] = pbMsg.Values[5];
    inOutObject->Values[6] = pbMsg.Values[6];
    inOutObject->Values[7] = pbMsg.Values[7];
    inOutObject->Values[8] = pbMsg.Values[8];
    inOutObject->Values[9] = pbMsg.Values[9];
    inOutObject->Values[10] = pbMsg.Values[10];
    inOutObject->Values[11] = pbMsg.Values[11];
    inOutObject->Values[12] = pbMsg.Values[12];
    inOutObject->Values[13] = pbMsg.Values[13];
    inOutObject->Values[14] = pbMsg.Values[14];
    inOutObject->Values[15] = pbMsg.Values[15];
    inOutObject->Values[16] = pbMsg.Values[16];
    inOutObject->Values[17] = pbMsg.Values[17];
    inOutObject->RcPpmFrameLength = pbMsg.RcPpmFrameLength;
    inOutObject->RcLostFrameCount = pbMsg.RcLostFrameCount;
    inOutObject->RSSI = pbMsg.RSSI;

	return sizeof(PX4_InputRcMsg_t);
}


uint32 PX4_VehicleAttitudeMsg_t_Enc(const PX4_VehicleAttitudeMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleAttitudeMsg_t_pb pbMsg;

    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.RollSpeed = inObject->RollSpeed;
    /* Unroll indexes */
    pbMsg.Q_count = 4;
    pbMsg.Q[0] = inObject->Q[0];
    pbMsg.Q[1] = inObject->Q[1];
    pbMsg.Q[2] = inObject->Q[2];
    pbMsg.Q[3] = inObject->Q[3];
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.PitchSpeed = inObject->PitchSpeed;
    pbMsg.YawSpeed = inObject->YawSpeed;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleAttitudeMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleAttitudeMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleAttitudeMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleAttitudeMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleAttitudeMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->RollSpeed = pbMsg.RollSpeed;
    /* Unroll indexes */
    inOutObject->Q[0] = pbMsg.Q[0];
    inOutObject->Q[1] = pbMsg.Q[1];
    inOutObject->Q[2] = pbMsg.Q[2];
    inOutObject->Q[3] = pbMsg.Q[3];
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->PitchSpeed = pbMsg.PitchSpeed;
    inOutObject->YawSpeed = pbMsg.YawSpeed;

	return sizeof(PX4_VehicleAttitudeMsg_t);
}


uint32 PX4_VehicleAttitudeSetpointMsg_t_Enc(const PX4_VehicleAttitudeSetpointMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleAttitudeSetpointMsg_t_pb pbMsg;

    pbMsg.YawSpMoveRate = inObject->YawSpMoveRate;
    pbMsg.PitchResetIntegral = inObject->PitchResetIntegral;
    /* Unroll indexes */
    pbMsg.Q_D_count = 4;
    pbMsg.Q_D[0] = inObject->Q_D[0];
    pbMsg.Q_D[1] = inObject->Q_D[1];
    pbMsg.Q_D[2] = inObject->Q_D[2];
    pbMsg.Q_D[3] = inObject->Q_D[3];
    pbMsg.FwControlYaw = inObject->FwControlYaw;
    pbMsg.YawBody = inObject->YawBody;
    pbMsg.PitchBody = inObject->PitchBody;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Q_D_Valid = inObject->Q_D_Valid;
    pbMsg.DisableMcYawControl = inObject->DisableMcYawControl;
    pbMsg.YawResetIntegral = inObject->YawResetIntegral;
    pbMsg.LandingGear = inObject->LandingGear;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.ApplyFlaps = inObject->ApplyFlaps;
    pbMsg.Thrust = inObject->Thrust;
    pbMsg.RollBody = inObject->RollBody;
    pbMsg.RollResetIntegral = inObject->RollResetIntegral;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleAttitudeSetpointMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleAttitudeSetpointMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleAttitudeSetpointMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleAttitudeSetpointMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleAttitudeSetpointMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->YawSpMoveRate = pbMsg.YawSpMoveRate;
    inOutObject->PitchResetIntegral = pbMsg.PitchResetIntegral;
    /* Unroll indexes */
    inOutObject->Q_D[0] = pbMsg.Q_D[0];
    inOutObject->Q_D[1] = pbMsg.Q_D[1];
    inOutObject->Q_D[2] = pbMsg.Q_D[2];
    inOutObject->Q_D[3] = pbMsg.Q_D[3];
    inOutObject->FwControlYaw = pbMsg.FwControlYaw;
    inOutObject->YawBody = pbMsg.YawBody;
    inOutObject->PitchBody = pbMsg.PitchBody;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Q_D_Valid = pbMsg.Q_D_Valid;
    inOutObject->DisableMcYawControl = pbMsg.DisableMcYawControl;
    inOutObject->YawResetIntegral = pbMsg.YawResetIntegral;
    inOutObject->LandingGear = pbMsg.LandingGear;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->ApplyFlaps = pbMsg.ApplyFlaps;
    inOutObject->Thrust = pbMsg.Thrust;
    inOutObject->RollBody = pbMsg.RollBody;
    inOutObject->RollResetIntegral = pbMsg.RollResetIntegral;

	return sizeof(PX4_VehicleAttitudeSetpointMsg_t);
}


uint32 PX4_VehicleCommandMsg_t_Enc(const PX4_VehicleCommandMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleCommandMsg_t_pb pbMsg;

    pbMsg.Confirmation = inObject->Confirmation;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Param4 = inObject->Param4;
    pbMsg.Param7 = inObject->Param7;
    pbMsg.Param6 = inObject->Param6;
    pbMsg.Param5 = inObject->Param5;
    pbMsg.TargetComponent = inObject->TargetComponent;
    pbMsg.Command = inObject->Command;
    pbMsg.Param2 = inObject->Param2;
    pbMsg.Param1 = inObject->Param1;
    pbMsg.TargetSystem = inObject->TargetSystem;
    pbMsg.SourceSystem = inObject->SourceSystem;
    pbMsg.Param3 = inObject->Param3;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.SourceComponent = inObject->SourceComponent;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleCommandMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleCommandMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleCommandMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleCommandMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleCommandMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Confirmation = pbMsg.Confirmation;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Param4 = pbMsg.Param4;
    inOutObject->Param7 = pbMsg.Param7;
    inOutObject->Param6 = pbMsg.Param6;
    inOutObject->Param5 = pbMsg.Param5;
    inOutObject->TargetComponent = pbMsg.TargetComponent;
    inOutObject->Command = pbMsg.Command;
    inOutObject->Param2 = pbMsg.Param2;
    inOutObject->Param1 = pbMsg.Param1;
    inOutObject->TargetSystem = pbMsg.TargetSystem;
    inOutObject->SourceSystem = pbMsg.SourceSystem;
    inOutObject->Param3 = pbMsg.Param3;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->SourceComponent = pbMsg.SourceComponent;

	return sizeof(PX4_VehicleCommandMsg_t);
}


uint32 PX4_LedControlMsg_t_Enc(const PX4_LedControlMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_LedControlMsg_t_pb pbMsg;

    pbMsg.Color = inObject->Color;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Priority = inObject->Priority;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.LedMask = inObject->LedMask;
    pbMsg.Mode = inObject->Mode;
    pbMsg.NumBlinks = inObject->NumBlinks;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_LedControlMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_LedControlMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_LedControlMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_LedControlMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_LedControlMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Color = pbMsg.Color;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Priority = pbMsg.Priority;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->LedMask = pbMsg.LedMask;
    inOutObject->Mode = pbMsg.Mode;
    inOutObject->NumBlinks = pbMsg.NumBlinks;

	return sizeof(PX4_LedControlMsg_t);
}


uint32 PX4_AirspeedMsg_t_Enc(const PX4_AirspeedMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_AirspeedMsg_t_pb pbMsg;

    pbMsg.TrueAirspeed = inObject->TrueAirspeed;
    pbMsg.Confidence = inObject->Confidence;
    pbMsg.AirTemperature = inObject->AirTemperature;
    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.IndicatedAirspeed = inObject->IndicatedAirspeed;
    pbMsg.TrueAirspeedUnfiltered = inObject->TrueAirspeedUnfiltered;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_AirspeedMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_AirspeedMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_AirspeedMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_AirspeedMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_AirspeedMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->TrueAirspeed = pbMsg.TrueAirspeed;
    inOutObject->Confidence = pbMsg.Confidence;
    inOutObject->AirTemperature = pbMsg.AirTemperature;
    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->IndicatedAirspeed = pbMsg.IndicatedAirspeed;
    inOutObject->TrueAirspeedUnfiltered = pbMsg.TrueAirspeedUnfiltered;

	return sizeof(PX4_AirspeedMsg_t);
}


uint32 PX4_SafetyMsg_t_Enc(const PX4_SafetyMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SafetyMsg_t_pb pbMsg;

    pbMsg.SafetyOff = inObject->SafetyOff;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.SafetySwitchAvailable = inObject->SafetySwitchAvailable;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SafetyMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SafetyMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SafetyMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SafetyMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SafetyMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->SafetyOff = pbMsg.SafetyOff;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->SafetySwitchAvailable = pbMsg.SafetySwitchAvailable;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];

	return sizeof(PX4_SafetyMsg_t);
}


uint32 PX4_ActuatorControlsMsg_t_Enc(const PX4_ActuatorControlsMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_ActuatorControlsMsg_t_pb pbMsg;

    /* Unroll indexes */
    pbMsg.Control_count = 8;
    pbMsg.Control[0] = inObject->Control[0];
    pbMsg.Control[1] = inObject->Control[1];
    pbMsg.Control[2] = inObject->Control[2];
    pbMsg.Control[3] = inObject->Control[3];
    pbMsg.Control[4] = inObject->Control[4];
    pbMsg.Control[5] = inObject->Control[5];
    pbMsg.Control[6] = inObject->Control[6];
    pbMsg.Control[7] = inObject->Control[7];
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.SampleTime = inObject->SampleTime;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_ActuatorControlsMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_ActuatorControlsMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_ActuatorControlsMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_ActuatorControlsMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_ActuatorControlsMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    /* Unroll indexes */
    inOutObject->Control[0] = pbMsg.Control[0];
    inOutObject->Control[1] = pbMsg.Control[1];
    inOutObject->Control[2] = pbMsg.Control[2];
    inOutObject->Control[3] = pbMsg.Control[3];
    inOutObject->Control[4] = pbMsg.Control[4];
    inOutObject->Control[5] = pbMsg.Control[5];
    inOutObject->Control[6] = pbMsg.Control[6];
    inOutObject->Control[7] = pbMsg.Control[7];
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->SampleTime = pbMsg.SampleTime;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];

	return sizeof(PX4_ActuatorControlsMsg_t);
}


uint32 PX4_BatteryStatusMsg_t_Enc(const PX4_BatteryStatusMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_BatteryStatusMsg_t_pb pbMsg;

    pbMsg.Scale = inObject->Scale;
    pbMsg.VoltageFiltered = inObject->VoltageFiltered;
    pbMsg.CellCount = inObject->CellCount;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.CurrentFiltered = inObject->CurrentFiltered;
    pbMsg.Current = inObject->Current;
    pbMsg.Warning = inObject->Warning;
    pbMsg.Connected = inObject->Connected;
    pbMsg.Voltage = inObject->Voltage;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.Remaining = inObject->Remaining;
    pbMsg.Discharged = inObject->Discharged;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_BatteryStatusMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_BatteryStatusMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_BatteryStatusMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_BatteryStatusMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_BatteryStatusMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Scale = pbMsg.Scale;
    inOutObject->VoltageFiltered = pbMsg.VoltageFiltered;
    inOutObject->CellCount = pbMsg.CellCount;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->CurrentFiltered = pbMsg.CurrentFiltered;
    inOutObject->Current = pbMsg.Current;
    inOutObject->Warning = pbMsg.Warning;
    inOutObject->Connected = pbMsg.Connected;
    inOutObject->Voltage = pbMsg.Voltage;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->Remaining = pbMsg.Remaining;
    inOutObject->Discharged = pbMsg.Discharged;

	return sizeof(PX4_BatteryStatusMsg_t);
}


uint32 PX4_VehicleStatusMsg_t_Enc(const PX4_VehicleStatusMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleStatusMsg_t_pb pbMsg;

    pbMsg.HilState = inObject->HilState;
    pbMsg.Failsafe = inObject->Failsafe;
    pbMsg.MissionFailure = inObject->MissionFailure;
    pbMsg.VtolFwPermanentStab = inObject->VtolFwPermanentStab;
    pbMsg.ArmingState = inObject->ArmingState;
    pbMsg.EngineFailureCmd = inObject->EngineFailureCmd;
    pbMsg.NavState = inObject->NavState;
    pbMsg.OnboardControlSensorsPresent = inObject->OnboardControlSensorsPresent;
    pbMsg.DataLinkLostCounter = inObject->DataLinkLostCounter;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.SystemID = inObject->SystemID;
    pbMsg.OnboardControlSensorsEnabled = inObject->OnboardControlSensorsEnabled;
    pbMsg.EngineFailure = inObject->EngineFailure;
    pbMsg.InTransitionMode = inObject->InTransitionMode;
    pbMsg.RcSignalLost = inObject->RcSignalLost;
    pbMsg.RcInputMode = inObject->RcInputMode;
    pbMsg.IsRotaryWing = inObject->IsRotaryWing;
    pbMsg.DataLinkLost = inObject->DataLinkLost;
    pbMsg.SystemType = inObject->SystemType;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.OnboardControlSensorsHealth = inObject->OnboardControlSensorsHealth;
    pbMsg.ComponentID = inObject->ComponentID;
    pbMsg.IsVtol = inObject->IsVtol;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleStatusMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleStatusMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleStatusMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleStatusMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleStatusMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->HilState = pbMsg.HilState;
    inOutObject->Failsafe = pbMsg.Failsafe;
    inOutObject->MissionFailure = pbMsg.MissionFailure;
    inOutObject->VtolFwPermanentStab = pbMsg.VtolFwPermanentStab;
    inOutObject->ArmingState = pbMsg.ArmingState;
    inOutObject->EngineFailureCmd = pbMsg.EngineFailureCmd;
    inOutObject->NavState = pbMsg.NavState;
    inOutObject->OnboardControlSensorsPresent = pbMsg.OnboardControlSensorsPresent;
    inOutObject->DataLinkLostCounter = pbMsg.DataLinkLostCounter;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->SystemID = pbMsg.SystemID;
    inOutObject->OnboardControlSensorsEnabled = pbMsg.OnboardControlSensorsEnabled;
    inOutObject->EngineFailure = pbMsg.EngineFailure;
    inOutObject->InTransitionMode = pbMsg.InTransitionMode;
    inOutObject->RcSignalLost = pbMsg.RcSignalLost;
    inOutObject->RcInputMode = pbMsg.RcInputMode;
    inOutObject->IsRotaryWing = pbMsg.IsRotaryWing;
    inOutObject->DataLinkLost = pbMsg.DataLinkLost;
    inOutObject->SystemType = pbMsg.SystemType;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->OnboardControlSensorsHealth = pbMsg.OnboardControlSensorsHealth;
    inOutObject->ComponentID = pbMsg.ComponentID;
    inOutObject->IsVtol = pbMsg.IsVtol;

	return sizeof(PX4_VehicleStatusMsg_t);
}


uint32 PX4_PositionSetpointTripletMsg_t_Enc(const PX4_PositionSetpointTripletMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_PositionSetpointTripletMsg_t_pb pbMsg;

    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.Current.AccelerationIsForce = inObject->Current.AccelerationIsForce;
    pbMsg.Current.DisableMcYawControl = inObject->Current.DisableMcYawControl;
    pbMsg.Current.Yaw = inObject->Current.Yaw;
    pbMsg.Current.Lon = inObject->Current.Lon;
    pbMsg.Current.PitchMin = inObject->Current.PitchMin;
    pbMsg.Current.VX = inObject->Current.VX;
    pbMsg.Current.Valid = inObject->Current.Valid;
    pbMsg.Current.AY = inObject->Current.AY;
    pbMsg.Current.YawValid = inObject->Current.YawValid;
    pbMsg.Current.X = inObject->Current.X;
    pbMsg.Current.PositionValid = inObject->Current.PositionValid;
    pbMsg.Current.Yawspeed = inObject->Current.Yawspeed;
    pbMsg.Current.VelocityValid = inObject->Current.VelocityValid;
    pbMsg.Current.Type = inObject->Current.Type;
    pbMsg.Current.YawspeedValid = inObject->Current.YawspeedValid;
    pbMsg.Current.VY = inObject->Current.VY;
    pbMsg.Current.Z = inObject->Current.Z;
    pbMsg.Current.CruisingThrottle = inObject->Current.CruisingThrottle;
    pbMsg.Current.Timestamp = inObject->Current.Timestamp;
    pbMsg.Current.VelocityFrame = inObject->Current.VelocityFrame;
    pbMsg.Current.Lat = inObject->Current.Lat;
    pbMsg.Current.AltValid = inObject->Current.AltValid;
    pbMsg.Current.CruisingSpeed = inObject->Current.CruisingSpeed;
    pbMsg.Current.LoiterDirection = inObject->Current.LoiterDirection;
    pbMsg.Current.Y = inObject->Current.Y;
    pbMsg.Current.AX = inObject->Current.AX;
    pbMsg.Current.VZ = inObject->Current.VZ;
    pbMsg.Current.AcceptanceRadius = inObject->Current.AcceptanceRadius;
    pbMsg.Current.AccelerationValid = inObject->Current.AccelerationValid;
    pbMsg.Current.AZ = inObject->Current.AZ;
    pbMsg.Current.LoiterRadius = inObject->Current.LoiterRadius;
    pbMsg.Current.Alt = inObject->Current.Alt;
    pbMsg.Previous.AccelerationIsForce = inObject->Previous.AccelerationIsForce;
    pbMsg.Previous.DisableMcYawControl = inObject->Previous.DisableMcYawControl;
    pbMsg.Previous.Yaw = inObject->Previous.Yaw;
    pbMsg.Previous.Lon = inObject->Previous.Lon;
    pbMsg.Previous.PitchMin = inObject->Previous.PitchMin;
    pbMsg.Previous.VX = inObject->Previous.VX;
    pbMsg.Previous.Valid = inObject->Previous.Valid;
    pbMsg.Previous.AY = inObject->Previous.AY;
    pbMsg.Previous.YawValid = inObject->Previous.YawValid;
    pbMsg.Previous.X = inObject->Previous.X;
    pbMsg.Previous.PositionValid = inObject->Previous.PositionValid;
    pbMsg.Previous.Yawspeed = inObject->Previous.Yawspeed;
    pbMsg.Previous.VelocityValid = inObject->Previous.VelocityValid;
    pbMsg.Previous.Type = inObject->Previous.Type;
    pbMsg.Previous.YawspeedValid = inObject->Previous.YawspeedValid;
    pbMsg.Previous.VY = inObject->Previous.VY;
    pbMsg.Previous.Z = inObject->Previous.Z;
    pbMsg.Previous.CruisingThrottle = inObject->Previous.CruisingThrottle;
    pbMsg.Previous.Timestamp = inObject->Previous.Timestamp;
    pbMsg.Previous.VelocityFrame = inObject->Previous.VelocityFrame;
    pbMsg.Previous.Lat = inObject->Previous.Lat;
    pbMsg.Previous.AltValid = inObject->Previous.AltValid;
    pbMsg.Previous.CruisingSpeed = inObject->Previous.CruisingSpeed;
    pbMsg.Previous.LoiterDirection = inObject->Previous.LoiterDirection;
    pbMsg.Previous.Y = inObject->Previous.Y;
    pbMsg.Previous.AX = inObject->Previous.AX;
    pbMsg.Previous.VZ = inObject->Previous.VZ;
    pbMsg.Previous.AcceptanceRadius = inObject->Previous.AcceptanceRadius;
    pbMsg.Previous.AccelerationValid = inObject->Previous.AccelerationValid;
    pbMsg.Previous.AZ = inObject->Previous.AZ;
    pbMsg.Previous.LoiterRadius = inObject->Previous.LoiterRadius;
    pbMsg.Previous.Alt = inObject->Previous.Alt;
    pbMsg.Next.AccelerationIsForce = inObject->Next.AccelerationIsForce;
    pbMsg.Next.DisableMcYawControl = inObject->Next.DisableMcYawControl;
    pbMsg.Next.Yaw = inObject->Next.Yaw;
    pbMsg.Next.Lon = inObject->Next.Lon;
    pbMsg.Next.PitchMin = inObject->Next.PitchMin;
    pbMsg.Next.VX = inObject->Next.VX;
    pbMsg.Next.Valid = inObject->Next.Valid;
    pbMsg.Next.AY = inObject->Next.AY;
    pbMsg.Next.YawValid = inObject->Next.YawValid;
    pbMsg.Next.X = inObject->Next.X;
    pbMsg.Next.PositionValid = inObject->Next.PositionValid;
    pbMsg.Next.Yawspeed = inObject->Next.Yawspeed;
    pbMsg.Next.VelocityValid = inObject->Next.VelocityValid;
    pbMsg.Next.Type = inObject->Next.Type;
    pbMsg.Next.YawspeedValid = inObject->Next.YawspeedValid;
    pbMsg.Next.VY = inObject->Next.VY;
    pbMsg.Next.Z = inObject->Next.Z;
    pbMsg.Next.CruisingThrottle = inObject->Next.CruisingThrottle;
    pbMsg.Next.Timestamp = inObject->Next.Timestamp;
    pbMsg.Next.VelocityFrame = inObject->Next.VelocityFrame;
    pbMsg.Next.Lat = inObject->Next.Lat;
    pbMsg.Next.AltValid = inObject->Next.AltValid;
    pbMsg.Next.CruisingSpeed = inObject->Next.CruisingSpeed;
    pbMsg.Next.LoiterDirection = inObject->Next.LoiterDirection;
    pbMsg.Next.Y = inObject->Next.Y;
    pbMsg.Next.AX = inObject->Next.AX;
    pbMsg.Next.VZ = inObject->Next.VZ;
    pbMsg.Next.AcceptanceRadius = inObject->Next.AcceptanceRadius;
    pbMsg.Next.AccelerationValid = inObject->Next.AccelerationValid;
    pbMsg.Next.AZ = inObject->Next.AZ;
    pbMsg.Next.LoiterRadius = inObject->Next.LoiterRadius;
    pbMsg.Next.Alt = inObject->Next.Alt;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_PositionSetpointTripletMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_PositionSetpointTripletMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_PositionSetpointTripletMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_PositionSetpointTripletMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_PositionSetpointTripletMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->Current.AccelerationIsForce = pbMsg.Current.AccelerationIsForce;
    inOutObject->Current.DisableMcYawControl = pbMsg.Current.DisableMcYawControl;
    inOutObject->Current.Yaw = pbMsg.Current.Yaw;
    inOutObject->Current.Lon = pbMsg.Current.Lon;
    inOutObject->Current.PitchMin = pbMsg.Current.PitchMin;
    inOutObject->Current.VX = pbMsg.Current.VX;
    inOutObject->Current.Valid = pbMsg.Current.Valid;
    inOutObject->Current.AY = pbMsg.Current.AY;
    inOutObject->Current.YawValid = pbMsg.Current.YawValid;
    inOutObject->Current.X = pbMsg.Current.X;
    inOutObject->Current.PositionValid = pbMsg.Current.PositionValid;
    inOutObject->Current.Yawspeed = pbMsg.Current.Yawspeed;
    inOutObject->Current.VelocityValid = pbMsg.Current.VelocityValid;
    inOutObject->Current.Type = pbMsg.Current.Type;
    inOutObject->Current.YawspeedValid = pbMsg.Current.YawspeedValid;
    inOutObject->Current.VY = pbMsg.Current.VY;
    inOutObject->Current.Z = pbMsg.Current.Z;
    inOutObject->Current.CruisingThrottle = pbMsg.Current.CruisingThrottle;
    inOutObject->Current.Timestamp = pbMsg.Current.Timestamp;
    inOutObject->Current.VelocityFrame = pbMsg.Current.VelocityFrame;
    inOutObject->Current.Lat = pbMsg.Current.Lat;
    inOutObject->Current.AltValid = pbMsg.Current.AltValid;
    inOutObject->Current.CruisingSpeed = pbMsg.Current.CruisingSpeed;
    inOutObject->Current.LoiterDirection = pbMsg.Current.LoiterDirection;
    inOutObject->Current.Y = pbMsg.Current.Y;
    inOutObject->Current.AX = pbMsg.Current.AX;
    inOutObject->Current.VZ = pbMsg.Current.VZ;
    inOutObject->Current.AcceptanceRadius = pbMsg.Current.AcceptanceRadius;
    inOutObject->Current.AccelerationValid = pbMsg.Current.AccelerationValid;
    inOutObject->Current.AZ = pbMsg.Current.AZ;
    inOutObject->Current.LoiterRadius = pbMsg.Current.LoiterRadius;
    inOutObject->Current.Alt = pbMsg.Current.Alt;
    inOutObject->Previous.AccelerationIsForce = pbMsg.Previous.AccelerationIsForce;
    inOutObject->Previous.DisableMcYawControl = pbMsg.Previous.DisableMcYawControl;
    inOutObject->Previous.Yaw = pbMsg.Previous.Yaw;
    inOutObject->Previous.Lon = pbMsg.Previous.Lon;
    inOutObject->Previous.PitchMin = pbMsg.Previous.PitchMin;
    inOutObject->Previous.VX = pbMsg.Previous.VX;
    inOutObject->Previous.Valid = pbMsg.Previous.Valid;
    inOutObject->Previous.AY = pbMsg.Previous.AY;
    inOutObject->Previous.YawValid = pbMsg.Previous.YawValid;
    inOutObject->Previous.X = pbMsg.Previous.X;
    inOutObject->Previous.PositionValid = pbMsg.Previous.PositionValid;
    inOutObject->Previous.Yawspeed = pbMsg.Previous.Yawspeed;
    inOutObject->Previous.VelocityValid = pbMsg.Previous.VelocityValid;
    inOutObject->Previous.Type = pbMsg.Previous.Type;
    inOutObject->Previous.YawspeedValid = pbMsg.Previous.YawspeedValid;
    inOutObject->Previous.VY = pbMsg.Previous.VY;
    inOutObject->Previous.Z = pbMsg.Previous.Z;
    inOutObject->Previous.CruisingThrottle = pbMsg.Previous.CruisingThrottle;
    inOutObject->Previous.Timestamp = pbMsg.Previous.Timestamp;
    inOutObject->Previous.VelocityFrame = pbMsg.Previous.VelocityFrame;
    inOutObject->Previous.Lat = pbMsg.Previous.Lat;
    inOutObject->Previous.AltValid = pbMsg.Previous.AltValid;
    inOutObject->Previous.CruisingSpeed = pbMsg.Previous.CruisingSpeed;
    inOutObject->Previous.LoiterDirection = pbMsg.Previous.LoiterDirection;
    inOutObject->Previous.Y = pbMsg.Previous.Y;
    inOutObject->Previous.AX = pbMsg.Previous.AX;
    inOutObject->Previous.VZ = pbMsg.Previous.VZ;
    inOutObject->Previous.AcceptanceRadius = pbMsg.Previous.AcceptanceRadius;
    inOutObject->Previous.AccelerationValid = pbMsg.Previous.AccelerationValid;
    inOutObject->Previous.AZ = pbMsg.Previous.AZ;
    inOutObject->Previous.LoiterRadius = pbMsg.Previous.LoiterRadius;
    inOutObject->Previous.Alt = pbMsg.Previous.Alt;
    inOutObject->Next.AccelerationIsForce = pbMsg.Next.AccelerationIsForce;
    inOutObject->Next.DisableMcYawControl = pbMsg.Next.DisableMcYawControl;
    inOutObject->Next.Yaw = pbMsg.Next.Yaw;
    inOutObject->Next.Lon = pbMsg.Next.Lon;
    inOutObject->Next.PitchMin = pbMsg.Next.PitchMin;
    inOutObject->Next.VX = pbMsg.Next.VX;
    inOutObject->Next.Valid = pbMsg.Next.Valid;
    inOutObject->Next.AY = pbMsg.Next.AY;
    inOutObject->Next.YawValid = pbMsg.Next.YawValid;
    inOutObject->Next.X = pbMsg.Next.X;
    inOutObject->Next.PositionValid = pbMsg.Next.PositionValid;
    inOutObject->Next.Yawspeed = pbMsg.Next.Yawspeed;
    inOutObject->Next.VelocityValid = pbMsg.Next.VelocityValid;
    inOutObject->Next.Type = pbMsg.Next.Type;
    inOutObject->Next.YawspeedValid = pbMsg.Next.YawspeedValid;
    inOutObject->Next.VY = pbMsg.Next.VY;
    inOutObject->Next.Z = pbMsg.Next.Z;
    inOutObject->Next.CruisingThrottle = pbMsg.Next.CruisingThrottle;
    inOutObject->Next.Timestamp = pbMsg.Next.Timestamp;
    inOutObject->Next.VelocityFrame = pbMsg.Next.VelocityFrame;
    inOutObject->Next.Lat = pbMsg.Next.Lat;
    inOutObject->Next.AltValid = pbMsg.Next.AltValid;
    inOutObject->Next.CruisingSpeed = pbMsg.Next.CruisingSpeed;
    inOutObject->Next.LoiterDirection = pbMsg.Next.LoiterDirection;
    inOutObject->Next.Y = pbMsg.Next.Y;
    inOutObject->Next.AX = pbMsg.Next.AX;
    inOutObject->Next.VZ = pbMsg.Next.VZ;
    inOutObject->Next.AcceptanceRadius = pbMsg.Next.AcceptanceRadius;
    inOutObject->Next.AccelerationValid = pbMsg.Next.AccelerationValid;
    inOutObject->Next.AZ = pbMsg.Next.AZ;
    inOutObject->Next.LoiterRadius = pbMsg.Next.LoiterRadius;
    inOutObject->Next.Alt = pbMsg.Next.Alt;

	return sizeof(PX4_PositionSetpointTripletMsg_t);
}


uint32 PX4_VehicleGpsPositionMsg_t_Enc(const PX4_VehicleGpsPositionMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleGpsPositionMsg_t_pb pbMsg;

    pbMsg.FixType = inObject->FixType;
    pbMsg.SatellitesUsed = inObject->SatellitesUsed;
    pbMsg.Lon = inObject->Lon;
    pbMsg.Vel_d_m_s = inObject->Vel_d_m_s;
    pbMsg.COG = inObject->COG;
    pbMsg.SVariance = inObject->SVariance;
    pbMsg.JammingIndicator = inObject->JammingIndicator;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.VelNedValid = inObject->VelNedValid;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.Lat = inObject->Lat;
    pbMsg.VDOP = inObject->VDOP;
    pbMsg.HDOP = inObject->HDOP;
    pbMsg.TimestampTimeRelative = inObject->TimestampTimeRelative;
    pbMsg.CVariance = inObject->CVariance;
    pbMsg.TimeUtcUsec = inObject->TimeUtcUsec;
    pbMsg.AltEllipsoid = inObject->AltEllipsoid;
    pbMsg.NoisePerMs = inObject->NoisePerMs;
    pbMsg.EpV = inObject->EpV;
    pbMsg.Vel_n_m_s = inObject->Vel_n_m_s;
    pbMsg.Vel_m_s = inObject->Vel_m_s;
    pbMsg.EpH = inObject->EpH;
    pbMsg.Alt = inObject->Alt;
    pbMsg.Vel_e_m_s = inObject->Vel_e_m_s;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleGpsPositionMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleGpsPositionMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleGpsPositionMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleGpsPositionMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleGpsPositionMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->FixType = pbMsg.FixType;
    inOutObject->SatellitesUsed = pbMsg.SatellitesUsed;
    inOutObject->Lon = pbMsg.Lon;
    inOutObject->Vel_d_m_s = pbMsg.Vel_d_m_s;
    inOutObject->COG = pbMsg.COG;
    inOutObject->SVariance = pbMsg.SVariance;
    inOutObject->JammingIndicator = pbMsg.JammingIndicator;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->VelNedValid = pbMsg.VelNedValid;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->Lat = pbMsg.Lat;
    inOutObject->VDOP = pbMsg.VDOP;
    inOutObject->HDOP = pbMsg.HDOP;
    inOutObject->TimestampTimeRelative = pbMsg.TimestampTimeRelative;
    inOutObject->CVariance = pbMsg.CVariance;
    inOutObject->TimeUtcUsec = pbMsg.TimeUtcUsec;
    inOutObject->AltEllipsoid = pbMsg.AltEllipsoid;
    inOutObject->NoisePerMs = pbMsg.NoisePerMs;
    inOutObject->EpV = pbMsg.EpV;
    inOutObject->Vel_n_m_s = pbMsg.Vel_n_m_s;
    inOutObject->Vel_m_s = pbMsg.Vel_m_s;
    inOutObject->EpH = pbMsg.EpH;
    inOutObject->Alt = pbMsg.Alt;
    inOutObject->Vel_e_m_s = pbMsg.Vel_e_m_s;

	return sizeof(PX4_VehicleGpsPositionMsg_t);
}


uint32 PX4_VehicleLocalPositionSetpointMsg_t_Enc(const PX4_VehicleLocalPositionSetpointMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleLocalPositionSetpointMsg_t_pb pbMsg;

    pbMsg.VY = inObject->VY;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Yaw = inObject->Yaw;
    pbMsg.VX = inObject->VX;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.AccY = inObject->AccY;
    pbMsg.AccX = inObject->AccX;
    pbMsg.AccZ = inObject->AccZ;
    pbMsg.Y = inObject->Y;
    pbMsg.X = inObject->X;
    pbMsg.VZ = inObject->VZ;
    pbMsg.Z = inObject->Z;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleLocalPositionSetpointMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleLocalPositionSetpointMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleLocalPositionSetpointMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleLocalPositionSetpointMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleLocalPositionSetpointMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->VY = pbMsg.VY;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Yaw = pbMsg.Yaw;
    inOutObject->VX = pbMsg.VX;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->AccY = pbMsg.AccY;
    inOutObject->AccX = pbMsg.AccX;
    inOutObject->AccZ = pbMsg.AccZ;
    inOutObject->Y = pbMsg.Y;
    inOutObject->X = pbMsg.X;
    inOutObject->VZ = pbMsg.VZ;
    inOutObject->Z = pbMsg.Z;

	return sizeof(PX4_VehicleLocalPositionSetpointMsg_t);
}


uint32 PX4_HomePositionMsg_t_Enc(const PX4_HomePositionMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_HomePositionMsg_t_pb pbMsg;

    pbMsg.Y = inObject->Y;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Yaw = inObject->Yaw;
    pbMsg.Lon = inObject->Lon;
    pbMsg.DirectionZ = inObject->DirectionZ;
    pbMsg.DirectionY = inObject->DirectionY;
    pbMsg.DirectionX = inObject->DirectionX;
    pbMsg.Lat = inObject->Lat;
    pbMsg.X = inObject->X;
    pbMsg.Alt = inObject->Alt;
    pbMsg.Z = inObject->Z;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_HomePositionMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_HomePositionMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_HomePositionMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_HomePositionMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_HomePositionMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Y = pbMsg.Y;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Yaw = pbMsg.Yaw;
    inOutObject->Lon = pbMsg.Lon;
    inOutObject->DirectionZ = pbMsg.DirectionZ;
    inOutObject->DirectionY = pbMsg.DirectionY;
    inOutObject->DirectionX = pbMsg.DirectionX;
    inOutObject->Lat = pbMsg.Lat;
    inOutObject->X = pbMsg.X;
    inOutObject->Alt = pbMsg.Alt;
    inOutObject->Z = pbMsg.Z;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];

	return sizeof(PX4_HomePositionMsg_t);
}


uint32 PX4_VehicleLocalPositionMsg_t_Enc(const PX4_VehicleLocalPositionMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleLocalPositionMsg_t_pb pbMsg;

    pbMsg.RefLat = inObject->RefLat;
    pbMsg.RefTimestamp = inObject->RefTimestamp;
    pbMsg.XY_ResetCounter = inObject->XY_ResetCounter;
    pbMsg.Yaw = inObject->Yaw;
    pbMsg.DistBottomRate = inObject->DistBottomRate;
    /* Unroll indexes */
    pbMsg.Delta_XY_count = 2;
    pbMsg.Delta_XY[0] = inObject->Delta_XY[0];
    pbMsg.Delta_XY[1] = inObject->Delta_XY[1];
    pbMsg.Z_Valid = inObject->Z_Valid;
    pbMsg.AY = inObject->AY;
    pbMsg.X = inObject->X;
    pbMsg.XY_Valid = inObject->XY_Valid;
    pbMsg.RefAlt = inObject->RefAlt;
    pbMsg.VY = inObject->VY;
    pbMsg.Z = inObject->Z;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.DistBottomValid = inObject->DistBottomValid;
    pbMsg.DistBottom = inObject->DistBottom;
    pbMsg.XY_Global = inObject->XY_Global;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.Y = inObject->Y;
    pbMsg.VXY_ResetCounter = inObject->VXY_ResetCounter;
    pbMsg.Delta_Z = inObject->Delta_Z;
    pbMsg.Z_ResetCounter = inObject->Z_ResetCounter;
    pbMsg.V_XY_Valid = inObject->V_XY_Valid;
    pbMsg.Z_Global = inObject->Z_Global;
    pbMsg.EstimatorType = inObject->EstimatorType;
    pbMsg.VX = inObject->VX;
    pbMsg.AX = inObject->AX;
    pbMsg.VZ = inObject->VZ;
    pbMsg.AZ = inObject->AZ;
    pbMsg.EvH = inObject->EvH;
    pbMsg.VZ_ResetCounter = inObject->VZ_ResetCounter;
    pbMsg.EpV = inObject->EpV;
    pbMsg.SurfaceBottomTimestamp = inObject->SurfaceBottomTimestamp;
    /* Unroll indexes */
    pbMsg.Delta_VXY_count = 2;
    pbMsg.Delta_VXY[0] = inObject->Delta_VXY[0];
    pbMsg.Delta_VXY[1] = inObject->Delta_VXY[1];
    pbMsg.Delta_VZ = inObject->Delta_VZ;
    pbMsg.EpH = inObject->EpH;
    pbMsg.V_Z_Valid = inObject->V_Z_Valid;
    pbMsg.RefLon = inObject->RefLon;
    pbMsg.EvV = inObject->EvV;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleLocalPositionMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleLocalPositionMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleLocalPositionMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleLocalPositionMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleLocalPositionMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->RefLat = pbMsg.RefLat;
    inOutObject->RefTimestamp = pbMsg.RefTimestamp;
    inOutObject->XY_ResetCounter = pbMsg.XY_ResetCounter;
    inOutObject->Yaw = pbMsg.Yaw;
    inOutObject->DistBottomRate = pbMsg.DistBottomRate;
    /* Unroll indexes */
    inOutObject->Delta_XY[0] = pbMsg.Delta_XY[0];
    inOutObject->Delta_XY[1] = pbMsg.Delta_XY[1];
    inOutObject->Z_Valid = pbMsg.Z_Valid;
    inOutObject->AY = pbMsg.AY;
    inOutObject->X = pbMsg.X;
    inOutObject->XY_Valid = pbMsg.XY_Valid;
    inOutObject->RefAlt = pbMsg.RefAlt;
    inOutObject->VY = pbMsg.VY;
    inOutObject->Z = pbMsg.Z;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->DistBottomValid = pbMsg.DistBottomValid;
    inOutObject->DistBottom = pbMsg.DistBottom;
    inOutObject->XY_Global = pbMsg.XY_Global;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->Y = pbMsg.Y;
    inOutObject->VXY_ResetCounter = pbMsg.VXY_ResetCounter;
    inOutObject->Delta_Z = pbMsg.Delta_Z;
    inOutObject->Z_ResetCounter = pbMsg.Z_ResetCounter;
    inOutObject->V_XY_Valid = pbMsg.V_XY_Valid;
    inOutObject->Z_Global = pbMsg.Z_Global;
    inOutObject->EstimatorType = pbMsg.EstimatorType;
    inOutObject->VX = pbMsg.VX;
    inOutObject->AX = pbMsg.AX;
    inOutObject->VZ = pbMsg.VZ;
    inOutObject->AZ = pbMsg.AZ;
    inOutObject->EvH = pbMsg.EvH;
    inOutObject->VZ_ResetCounter = pbMsg.VZ_ResetCounter;
    inOutObject->EpV = pbMsg.EpV;
    inOutObject->SurfaceBottomTimestamp = pbMsg.SurfaceBottomTimestamp;
    /* Unroll indexes */
    inOutObject->Delta_VXY[0] = pbMsg.Delta_VXY[0];
    inOutObject->Delta_VXY[1] = pbMsg.Delta_VXY[1];
    inOutObject->Delta_VZ = pbMsg.Delta_VZ;
    inOutObject->EpH = pbMsg.EpH;
    inOutObject->V_Z_Valid = pbMsg.V_Z_Valid;
    inOutObject->RefLon = pbMsg.RefLon;
    inOutObject->EvV = pbMsg.EvV;

	return sizeof(PX4_VehicleLocalPositionMsg_t);
}


uint32 PX4_TelemetryStatusMsg_t_Enc(const PX4_TelemetryStatusMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_TelemetryStatusMsg_t_pb pbMsg;

    pbMsg.RemoteNoise = inObject->RemoteNoise;
    pbMsg.RxErrors = inObject->RxErrors;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.TelemTime = inObject->TelemTime;
    pbMsg.HeartbeatTime = inObject->HeartbeatTime;
    pbMsg.Noise = inObject->Noise;
    pbMsg.SystemID = inObject->SystemID;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.RemoteRSSI = inObject->RemoteRSSI;
    pbMsg.RSSI = inObject->RSSI;
    pbMsg.Fixed = inObject->Fixed;
    pbMsg.Type = inObject->Type;
    pbMsg.ComponentID = inObject->ComponentID;
    pbMsg.TxBuf = inObject->TxBuf;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_TelemetryStatusMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_TelemetryStatusMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_TelemetryStatusMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_TelemetryStatusMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_TelemetryStatusMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->RemoteNoise = pbMsg.RemoteNoise;
    inOutObject->RxErrors = pbMsg.RxErrors;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->TelemTime = pbMsg.TelemTime;
    inOutObject->HeartbeatTime = pbMsg.HeartbeatTime;
    inOutObject->Noise = pbMsg.Noise;
    inOutObject->SystemID = pbMsg.SystemID;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->RemoteRSSI = pbMsg.RemoteRSSI;
    inOutObject->RSSI = pbMsg.RSSI;
    inOutObject->Fixed = pbMsg.Fixed;
    inOutObject->Type = pbMsg.Type;
    inOutObject->ComponentID = pbMsg.ComponentID;
    inOutObject->TxBuf = pbMsg.TxBuf;

	return sizeof(PX4_TelemetryStatusMsg_t);
}


uint32 PX4_SaturationStatus_t_Enc(const PX4_SaturationStatus_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SaturationStatus_t_pb pbMsg;

    pbMsg.Value = inObject->Value;
    pbMsg.Flags.ThrustNeg = inObject->Flags.ThrustNeg;
    pbMsg.Flags.MotorPos = inObject->Flags.MotorPos;
    pbMsg.Flags.PitchNeg = inObject->Flags.PitchNeg;
    pbMsg.Flags.ThrustPos = inObject->Flags.ThrustPos;
    pbMsg.Flags.PitchPos = inObject->Flags.PitchPos;
    pbMsg.Flags.RollPos = inObject->Flags.RollPos;
    pbMsg.Flags.MotorNeg = inObject->Flags.MotorNeg;
    pbMsg.Flags.YawNeg = inObject->Flags.YawNeg;
    pbMsg.Flags.RollNeg = inObject->Flags.RollNeg;
    pbMsg.Flags.YawPos = inObject->Flags.YawPos;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SaturationStatus_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SaturationStatus_t_Dec(const char *inBuffer, uint32 inSize, PX4_SaturationStatus_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SaturationStatus_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SaturationStatus_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Value = pbMsg.Value;
    inOutObject->Flags.ThrustNeg = pbMsg.Flags.ThrustNeg;
    inOutObject->Flags.MotorPos = pbMsg.Flags.MotorPos;
    inOutObject->Flags.PitchNeg = pbMsg.Flags.PitchNeg;
    inOutObject->Flags.ThrustPos = pbMsg.Flags.ThrustPos;
    inOutObject->Flags.PitchPos = pbMsg.Flags.PitchPos;
    inOutObject->Flags.RollPos = pbMsg.Flags.RollPos;
    inOutObject->Flags.MotorNeg = pbMsg.Flags.MotorNeg;
    inOutObject->Flags.YawNeg = pbMsg.Flags.YawNeg;
    inOutObject->Flags.RollNeg = pbMsg.Flags.RollNeg;
    inOutObject->Flags.YawPos = pbMsg.Flags.YawPos;

	return sizeof(PX4_SaturationStatus_t);
}


uint32 PX4_VehicleRatesSetpointMsg_t_Enc(const PX4_VehicleRatesSetpointMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleRatesSetpointMsg_t_pb pbMsg;

    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Yaw = inObject->Yaw;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.Pitch = inObject->Pitch;
    pbMsg.Thrust = inObject->Thrust;
    pbMsg.Roll = inObject->Roll;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleRatesSetpointMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleRatesSetpointMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleRatesSetpointMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleRatesSetpointMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleRatesSetpointMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Yaw = pbMsg.Yaw;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->Pitch = pbMsg.Pitch;
    inOutObject->Thrust = pbMsg.Thrust;
    inOutObject->Roll = pbMsg.Roll;

	return sizeof(PX4_VehicleRatesSetpointMsg_t);
}


uint32 PX4_VehicleControlModeMsg_t_Enc(const PX4_VehicleControlModeMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleControlModeMsg_t_pb pbMsg;

    pbMsg.ExternalManualOverrideOk = inObject->ExternalManualOverrideOk;
    pbMsg.ControlAltitudeEnabled = inObject->ControlAltitudeEnabled;
    pbMsg.ControlAutoEnabled = inObject->ControlAutoEnabled;
    pbMsg.ControlFixedHdgEnabled = inObject->ControlFixedHdgEnabled;
    pbMsg.ControlAccelerationEnabled = inObject->ControlAccelerationEnabled;
    pbMsg.SystemHilEnabled = inObject->SystemHilEnabled;
    pbMsg.ControlRatesEnabled = inObject->ControlRatesEnabled;
    pbMsg.ControlManualEnabled = inObject->ControlManualEnabled;
    pbMsg.ControlTerminationEnabled = inObject->ControlTerminationEnabled;
    pbMsg.ControlVelocityEnabled = inObject->ControlVelocityEnabled;
    pbMsg.ControlForceEnabled = inObject->ControlForceEnabled;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.ControlRattitudeEnabled = inObject->ControlRattitudeEnabled;
    pbMsg.ControlClimbRateEnabled = inObject->ControlClimbRateEnabled;
    pbMsg.ControlAttitudeEnabled = inObject->ControlAttitudeEnabled;
    pbMsg.ControlOffboardEnabled = inObject->ControlOffboardEnabled;
    pbMsg.Armed = inObject->Armed;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.ControlPositionEnabled = inObject->ControlPositionEnabled;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleControlModeMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleControlModeMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleControlModeMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleControlModeMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleControlModeMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->ExternalManualOverrideOk = pbMsg.ExternalManualOverrideOk;
    inOutObject->ControlAltitudeEnabled = pbMsg.ControlAltitudeEnabled;
    inOutObject->ControlAutoEnabled = pbMsg.ControlAutoEnabled;
    inOutObject->ControlFixedHdgEnabled = pbMsg.ControlFixedHdgEnabled;
    inOutObject->ControlAccelerationEnabled = pbMsg.ControlAccelerationEnabled;
    inOutObject->SystemHilEnabled = pbMsg.SystemHilEnabled;
    inOutObject->ControlRatesEnabled = pbMsg.ControlRatesEnabled;
    inOutObject->ControlManualEnabled = pbMsg.ControlManualEnabled;
    inOutObject->ControlTerminationEnabled = pbMsg.ControlTerminationEnabled;
    inOutObject->ControlVelocityEnabled = pbMsg.ControlVelocityEnabled;
    inOutObject->ControlForceEnabled = pbMsg.ControlForceEnabled;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->ControlRattitudeEnabled = pbMsg.ControlRattitudeEnabled;
    inOutObject->ControlClimbRateEnabled = pbMsg.ControlClimbRateEnabled;
    inOutObject->ControlAttitudeEnabled = pbMsg.ControlAttitudeEnabled;
    inOutObject->ControlOffboardEnabled = pbMsg.ControlOffboardEnabled;
    inOutObject->Armed = pbMsg.Armed;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->ControlPositionEnabled = pbMsg.ControlPositionEnabled;

	return sizeof(PX4_VehicleControlModeMsg_t);
}


uint32 PX4_VehicleLandDetectedMsg_t_Enc(const PX4_VehicleLandDetectedMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_VehicleLandDetectedMsg_t_pb pbMsg;

    pbMsg.Freefall = inObject->Freefall;
    pbMsg.AltMax = inObject->AltMax;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Landed = inObject->Landed;
    pbMsg.GroundContact = inObject->GroundContact;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_VehicleLandDetectedMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_VehicleLandDetectedMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_VehicleLandDetectedMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_VehicleLandDetectedMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_VehicleLandDetectedMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Freefall = pbMsg.Freefall;
    inOutObject->AltMax = pbMsg.AltMax;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Landed = pbMsg.Landed;
    inOutObject->GroundContact = pbMsg.GroundContact;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];

	return sizeof(PX4_VehicleLandDetectedMsg_t);
}


uint32 PX4_MissionMsg_t_Enc(const PX4_MissionMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_MissionMsg_t_pb pbMsg;

    pbMsg.Count = inObject->Count;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.DatamanID = inObject->DatamanID;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.CurrentSeq = inObject->CurrentSeq;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_MissionMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_MissionMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_MissionMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_MissionMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_MissionMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Count = pbMsg.Count;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->DatamanID = pbMsg.DatamanID;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->CurrentSeq = pbMsg.CurrentSeq;

	return sizeof(PX4_MissionMsg_t);
}


uint32 PX4_MissionResultMsg_t_Enc(const PX4_MissionResultMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_MissionResultMsg_t_pb pbMsg;

    pbMsg.ItemChangedIndex = inObject->ItemChangedIndex;
    pbMsg.InstanceCount = inObject->InstanceCount;
    pbMsg.SeqTotal = inObject->SeqTotal;
    pbMsg.FlightTermination = inObject->FlightTermination;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.StayInFailsafe = inObject->StayInFailsafe;
    pbMsg.SeqReached = inObject->SeqReached;
    pbMsg.Failure = inObject->Failure;
    pbMsg.Finished = inObject->Finished;
    pbMsg.ItemDoJumpChanged = inObject->ItemDoJumpChanged;
    pbMsg.Valid = inObject->Valid;
    pbMsg.ItemDoJumpRemaining = inObject->ItemDoJumpRemaining;
    pbMsg.Reached = inObject->Reached;
    pbMsg.SeqCurrent = inObject->SeqCurrent;
    pbMsg.Warning = inObject->Warning;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_MissionResultMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_MissionResultMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_MissionResultMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_MissionResultMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_MissionResultMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->ItemChangedIndex = pbMsg.ItemChangedIndex;
    inOutObject->InstanceCount = pbMsg.InstanceCount;
    inOutObject->SeqTotal = pbMsg.SeqTotal;
    inOutObject->FlightTermination = pbMsg.FlightTermination;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->StayInFailsafe = pbMsg.StayInFailsafe;
    inOutObject->SeqReached = pbMsg.SeqReached;
    inOutObject->Failure = pbMsg.Failure;
    inOutObject->Finished = pbMsg.Finished;
    inOutObject->ItemDoJumpChanged = pbMsg.ItemDoJumpChanged;
    inOutObject->Valid = pbMsg.Valid;
    inOutObject->ItemDoJumpRemaining = pbMsg.ItemDoJumpRemaining;
    inOutObject->Reached = pbMsg.Reached;
    inOutObject->SeqCurrent = pbMsg.SeqCurrent;
    inOutObject->Warning = pbMsg.Warning;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];

	return sizeof(PX4_MissionResultMsg_t);
}


uint32 PX4_RcChannelsMsg_t_Enc(const PX4_RcChannelsMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_RcChannelsMsg_t_pb pbMsg;

    /* Unroll indexes */
    pbMsg.Function_count = 26;
    pbMsg.Function[0] = inObject->Function[0];
    pbMsg.Function[1] = inObject->Function[1];
    pbMsg.Function[2] = inObject->Function[2];
    pbMsg.Function[3] = inObject->Function[3];
    pbMsg.Function[4] = inObject->Function[4];
    pbMsg.Function[5] = inObject->Function[5];
    pbMsg.Function[6] = inObject->Function[6];
    pbMsg.Function[7] = inObject->Function[7];
    pbMsg.Function[8] = inObject->Function[8];
    pbMsg.Function[9] = inObject->Function[9];
    pbMsg.Function[10] = inObject->Function[10];
    pbMsg.Function[11] = inObject->Function[11];
    pbMsg.Function[12] = inObject->Function[12];
    pbMsg.Function[13] = inObject->Function[13];
    pbMsg.Function[14] = inObject->Function[14];
    pbMsg.Function[15] = inObject->Function[15];
    pbMsg.Function[16] = inObject->Function[16];
    pbMsg.Function[17] = inObject->Function[17];
    pbMsg.Function[18] = inObject->Function[18];
    pbMsg.Function[19] = inObject->Function[19];
    pbMsg.Function[20] = inObject->Function[20];
    pbMsg.Function[21] = inObject->Function[21];
    pbMsg.Function[22] = inObject->Function[22];
    pbMsg.Function[23] = inObject->Function[23];
    pbMsg.Function[24] = inObject->Function[24];
    pbMsg.Function[25] = inObject->Function[25];
    pbMsg.ChannelCount = inObject->ChannelCount;
    pbMsg.TimestampLastValid = inObject->TimestampLastValid;
    pbMsg.FrameDropCount = inObject->FrameDropCount;
    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.Channels_count = 18;
    pbMsg.Channels[0] = inObject->Channels[0];
    pbMsg.Channels[1] = inObject->Channels[1];
    pbMsg.Channels[2] = inObject->Channels[2];
    pbMsg.Channels[3] = inObject->Channels[3];
    pbMsg.Channels[4] = inObject->Channels[4];
    pbMsg.Channels[5] = inObject->Channels[5];
    pbMsg.Channels[6] = inObject->Channels[6];
    pbMsg.Channels[7] = inObject->Channels[7];
    pbMsg.Channels[8] = inObject->Channels[8];
    pbMsg.Channels[9] = inObject->Channels[9];
    pbMsg.Channels[10] = inObject->Channels[10];
    pbMsg.Channels[11] = inObject->Channels[11];
    pbMsg.Channels[12] = inObject->Channels[12];
    pbMsg.Channels[13] = inObject->Channels[13];
    pbMsg.Channels[14] = inObject->Channels[14];
    pbMsg.Channels[15] = inObject->Channels[15];
    pbMsg.Channels[16] = inObject->Channels[16];
    pbMsg.Channels[17] = inObject->Channels[17];
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.RSSI = inObject->RSSI;
    pbMsg.SignalLost = inObject->SignalLost;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_RcChannelsMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_RcChannelsMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_RcChannelsMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_RcChannelsMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_RcChannelsMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    /* Unroll indexes */
    inOutObject->Function[0] = pbMsg.Function[0];
    inOutObject->Function[1] = pbMsg.Function[1];
    inOutObject->Function[2] = pbMsg.Function[2];
    inOutObject->Function[3] = pbMsg.Function[3];
    inOutObject->Function[4] = pbMsg.Function[4];
    inOutObject->Function[5] = pbMsg.Function[5];
    inOutObject->Function[6] = pbMsg.Function[6];
    inOutObject->Function[7] = pbMsg.Function[7];
    inOutObject->Function[8] = pbMsg.Function[8];
    inOutObject->Function[9] = pbMsg.Function[9];
    inOutObject->Function[10] = pbMsg.Function[10];
    inOutObject->Function[11] = pbMsg.Function[11];
    inOutObject->Function[12] = pbMsg.Function[12];
    inOutObject->Function[13] = pbMsg.Function[13];
    inOutObject->Function[14] = pbMsg.Function[14];
    inOutObject->Function[15] = pbMsg.Function[15];
    inOutObject->Function[16] = pbMsg.Function[16];
    inOutObject->Function[17] = pbMsg.Function[17];
    inOutObject->Function[18] = pbMsg.Function[18];
    inOutObject->Function[19] = pbMsg.Function[19];
    inOutObject->Function[20] = pbMsg.Function[20];
    inOutObject->Function[21] = pbMsg.Function[21];
    inOutObject->Function[22] = pbMsg.Function[22];
    inOutObject->Function[23] = pbMsg.Function[23];
    inOutObject->Function[24] = pbMsg.Function[24];
    inOutObject->Function[25] = pbMsg.Function[25];
    inOutObject->ChannelCount = pbMsg.ChannelCount;
    inOutObject->TimestampLastValid = pbMsg.TimestampLastValid;
    inOutObject->FrameDropCount = pbMsg.FrameDropCount;
    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->Channels[0] = pbMsg.Channels[0];
    inOutObject->Channels[1] = pbMsg.Channels[1];
    inOutObject->Channels[2] = pbMsg.Channels[2];
    inOutObject->Channels[3] = pbMsg.Channels[3];
    inOutObject->Channels[4] = pbMsg.Channels[4];
    inOutObject->Channels[5] = pbMsg.Channels[5];
    inOutObject->Channels[6] = pbMsg.Channels[6];
    inOutObject->Channels[7] = pbMsg.Channels[7];
    inOutObject->Channels[8] = pbMsg.Channels[8];
    inOutObject->Channels[9] = pbMsg.Channels[9];
    inOutObject->Channels[10] = pbMsg.Channels[10];
    inOutObject->Channels[11] = pbMsg.Channels[11];
    inOutObject->Channels[12] = pbMsg.Channels[12];
    inOutObject->Channels[13] = pbMsg.Channels[13];
    inOutObject->Channels[14] = pbMsg.Channels[14];
    inOutObject->Channels[15] = pbMsg.Channels[15];
    inOutObject->Channels[16] = pbMsg.Channels[16];
    inOutObject->Channels[17] = pbMsg.Channels[17];
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->RSSI = pbMsg.RSSI;
    inOutObject->SignalLost = pbMsg.SignalLost;

	return sizeof(PX4_RcChannelsMsg_t);
}


uint32 PX4_ControlStateMsg_t_Enc(const PX4_ControlStateMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_ControlStateMsg_t_pb pbMsg;

    pbMsg.PosY = inObject->PosY;
    pbMsg.Airspeed = inObject->Airspeed;
    pbMsg.PosZ = inObject->PosZ;
    pbMsg.PosX = inObject->PosX;
    /* Unroll indexes */
    pbMsg.VelVariance_count = 3;
    pbMsg.VelVariance[0] = inObject->VelVariance[0];
    pbMsg.VelVariance[1] = inObject->VelVariance[1];
    pbMsg.VelVariance[2] = inObject->VelVariance[2];
    /* Unroll indexes */
    pbMsg.DeltaQReset_count = 4;
    pbMsg.DeltaQReset[0] = inObject->DeltaQReset[0];
    pbMsg.DeltaQReset[1] = inObject->DeltaQReset[1];
    pbMsg.DeltaQReset[2] = inObject->DeltaQReset[2];
    pbMsg.DeltaQReset[3] = inObject->DeltaQReset[3];
    /* Unroll indexes */
    pbMsg.PosVariance_count = 3;
    pbMsg.PosVariance[0] = inObject->PosVariance[0];
    pbMsg.PosVariance[1] = inObject->PosVariance[1];
    pbMsg.PosVariance[2] = inObject->PosVariance[2];
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.RollRateBias = inObject->RollRateBias;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.PitchRateBias = inObject->PitchRateBias;
    pbMsg.VelX = inObject->VelX;
    /* Unroll indexes */
    pbMsg.Q_count = 4;
    pbMsg.Q[0] = inObject->Q[0];
    pbMsg.Q[1] = inObject->Q[1];
    pbMsg.Q[2] = inObject->Q[2];
    pbMsg.Q[3] = inObject->Q[3];
    pbMsg.AccY = inObject->AccY;
    pbMsg.AccX = inObject->AccX;
    pbMsg.VelY = inObject->VelY;
    pbMsg.AccZ = inObject->AccZ;
    pbMsg.YawRate = inObject->YawRate;
    pbMsg.QuatResetCounter = inObject->QuatResetCounter;
    pbMsg.RollRate = inObject->RollRate;
    pbMsg.AirspeedValid = inObject->AirspeedValid;
    pbMsg.PitchRate = inObject->PitchRate;
    pbMsg.HorzAccMag = inObject->HorzAccMag;
    pbMsg.YawRateBias = inObject->YawRateBias;
    pbMsg.VelZ = inObject->VelZ;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_ControlStateMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_ControlStateMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_ControlStateMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_ControlStateMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_ControlStateMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->PosY = pbMsg.PosY;
    inOutObject->Airspeed = pbMsg.Airspeed;
    inOutObject->PosZ = pbMsg.PosZ;
    inOutObject->PosX = pbMsg.PosX;
    /* Unroll indexes */
    inOutObject->VelVariance[0] = pbMsg.VelVariance[0];
    inOutObject->VelVariance[1] = pbMsg.VelVariance[1];
    inOutObject->VelVariance[2] = pbMsg.VelVariance[2];
    /* Unroll indexes */
    inOutObject->DeltaQReset[0] = pbMsg.DeltaQReset[0];
    inOutObject->DeltaQReset[1] = pbMsg.DeltaQReset[1];
    inOutObject->DeltaQReset[2] = pbMsg.DeltaQReset[2];
    inOutObject->DeltaQReset[3] = pbMsg.DeltaQReset[3];
    /* Unroll indexes */
    inOutObject->PosVariance[0] = pbMsg.PosVariance[0];
    inOutObject->PosVariance[1] = pbMsg.PosVariance[1];
    inOutObject->PosVariance[2] = pbMsg.PosVariance[2];
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->RollRateBias = pbMsg.RollRateBias;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->PitchRateBias = pbMsg.PitchRateBias;
    inOutObject->VelX = pbMsg.VelX;
    /* Unroll indexes */
    inOutObject->Q[0] = pbMsg.Q[0];
    inOutObject->Q[1] = pbMsg.Q[1];
    inOutObject->Q[2] = pbMsg.Q[2];
    inOutObject->Q[3] = pbMsg.Q[3];
    inOutObject->AccY = pbMsg.AccY;
    inOutObject->AccX = pbMsg.AccX;
    inOutObject->VelY = pbMsg.VelY;
    inOutObject->AccZ = pbMsg.AccZ;
    inOutObject->YawRate = pbMsg.YawRate;
    inOutObject->QuatResetCounter = pbMsg.QuatResetCounter;
    inOutObject->RollRate = pbMsg.RollRate;
    inOutObject->AirspeedValid = pbMsg.AirspeedValid;
    inOutObject->PitchRate = pbMsg.PitchRate;
    inOutObject->HorzAccMag = pbMsg.HorzAccMag;
    inOutObject->YawRateBias = pbMsg.YawRateBias;
    inOutObject->VelZ = pbMsg.VelZ;

	return sizeof(PX4_ControlStateMsg_t);
}


uint32 PX4_SubsystemInfoMsg_t_Enc(const PX4_SubsystemInfoMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SubsystemInfoMsg_t_pb pbMsg;

    pbMsg.Ok = inObject->Ok;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.SubsystemType = inObject->SubsystemType;
    pbMsg.Enabled = inObject->Enabled;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.Present = inObject->Present;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SubsystemInfoMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SubsystemInfoMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SubsystemInfoMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SubsystemInfoMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SubsystemInfoMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Ok = pbMsg.Ok;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->SubsystemType = pbMsg.SubsystemType;
    inOutObject->Enabled = pbMsg.Enabled;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->Present = pbMsg.Present;

	return sizeof(PX4_SubsystemInfoMsg_t);
}


uint32 PX4_ManualControlSetpointMsg_t_Enc(const PX4_ManualControlSetpointMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_ManualControlSetpointMsg_t_pb pbMsg;

    pbMsg.ModeSlot = inObject->ModeSlot;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.KillSwitch = inObject->KillSwitch;
    pbMsg.ArmSwitch = inObject->ArmSwitch;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.ManSwitch = inObject->ManSwitch;
    pbMsg.ModeSwitch = inObject->ModeSwitch;
    pbMsg.LoiterSwitch = inObject->LoiterSwitch;
    pbMsg.ReturnSwitch = inObject->ReturnSwitch;
    pbMsg.RattitudeSwitch = inObject->RattitudeSwitch;
    pbMsg.PosctlSwitch = inObject->PosctlSwitch;
    pbMsg.TransitionSwitch = inObject->TransitionSwitch;
    pbMsg.AcroSwitch = inObject->AcroSwitch;
    pbMsg.Flaps = inObject->Flaps;
    pbMsg.Y = inObject->Y;
    pbMsg.X = inObject->X;
    pbMsg.Z = inObject->Z;
    pbMsg.OffboardSwitch = inObject->OffboardSwitch;
    pbMsg.GearSwitch = inObject->GearSwitch;
    pbMsg.StabSwitch = inObject->StabSwitch;
    pbMsg.R = inObject->R;
    pbMsg.DataSource = inObject->DataSource;
    pbMsg.Aux2 = inObject->Aux2;
    pbMsg.Aux3 = inObject->Aux3;
    pbMsg.Aux1 = inObject->Aux1;
    pbMsg.Aux4 = inObject->Aux4;
    pbMsg.Aux5 = inObject->Aux5;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_ManualControlSetpointMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_ManualControlSetpointMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_ManualControlSetpointMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_ManualControlSetpointMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_ManualControlSetpointMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->ModeSlot = pbMsg.ModeSlot;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->KillSwitch = pbMsg.KillSwitch;
    inOutObject->ArmSwitch = pbMsg.ArmSwitch;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->ManSwitch = pbMsg.ManSwitch;
    inOutObject->ModeSwitch = pbMsg.ModeSwitch;
    inOutObject->LoiterSwitch = pbMsg.LoiterSwitch;
    inOutObject->ReturnSwitch = pbMsg.ReturnSwitch;
    inOutObject->RattitudeSwitch = pbMsg.RattitudeSwitch;
    inOutObject->PosctlSwitch = pbMsg.PosctlSwitch;
    inOutObject->TransitionSwitch = pbMsg.TransitionSwitch;
    inOutObject->AcroSwitch = pbMsg.AcroSwitch;
    inOutObject->Flaps = pbMsg.Flaps;
    inOutObject->Y = pbMsg.Y;
    inOutObject->X = pbMsg.X;
    inOutObject->Z = pbMsg.Z;
    inOutObject->OffboardSwitch = pbMsg.OffboardSwitch;
    inOutObject->GearSwitch = pbMsg.GearSwitch;
    inOutObject->StabSwitch = pbMsg.StabSwitch;
    inOutObject->R = pbMsg.R;
    inOutObject->DataSource = pbMsg.DataSource;
    inOutObject->Aux2 = pbMsg.Aux2;
    inOutObject->Aux3 = pbMsg.Aux3;
    inOutObject->Aux1 = pbMsg.Aux1;
    inOutObject->Aux4 = pbMsg.Aux4;
    inOutObject->Aux5 = pbMsg.Aux5;

	return sizeof(PX4_ManualControlSetpointMsg_t);
}


uint32 PX4_SensorBaroMsg_t_Enc(const PX4_SensorBaroMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SensorBaroMsg_t_pb pbMsg;

    pbMsg.Temperature = inObject->Temperature;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Altitude = inObject->Altitude;
    pbMsg.Pressure = inObject->Pressure;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.ErrorCount = inObject->ErrorCount;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SensorBaroMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SensorBaroMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SensorBaroMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SensorBaroMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SensorBaroMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Temperature = pbMsg.Temperature;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Altitude = pbMsg.Altitude;
    inOutObject->Pressure = pbMsg.Pressure;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->ErrorCount = pbMsg.ErrorCount;

	return sizeof(PX4_SensorBaroMsg_t);
}


uint32 PX4_SensorAccelMsg_t_Enc(const PX4_SensorAccelMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SensorAccelMsg_t_pb pbMsg;

    pbMsg.TemperatureRaw = inObject->TemperatureRaw;
    pbMsg.ZIntegral = inObject->ZIntegral;
    pbMsg.XIntegral = inObject->XIntegral;
    pbMsg.IntegralDt = inObject->IntegralDt;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.Range_m_s2 = inObject->Range_m_s2;
    pbMsg.ZRaw = inObject->ZRaw;
    pbMsg.YRaw = inObject->YRaw;
    pbMsg.Scaling = inObject->Scaling;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.YIntegral = inObject->YIntegral;
    pbMsg.DeviceID = inObject->DeviceID;
    pbMsg.Y = inObject->Y;
    pbMsg.X = inObject->X;
    pbMsg.Z = inObject->Z;
    pbMsg.ErrorCount = inObject->ErrorCount;
    pbMsg.XRaw = inObject->XRaw;
    pbMsg.Temperature = inObject->Temperature;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SensorAccelMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SensorAccelMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SensorAccelMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SensorAccelMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SensorAccelMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->TemperatureRaw = pbMsg.TemperatureRaw;
    inOutObject->ZIntegral = pbMsg.ZIntegral;
    inOutObject->XIntegral = pbMsg.XIntegral;
    inOutObject->IntegralDt = pbMsg.IntegralDt;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->Range_m_s2 = pbMsg.Range_m_s2;
    inOutObject->ZRaw = pbMsg.ZRaw;
    inOutObject->YRaw = pbMsg.YRaw;
    inOutObject->Scaling = pbMsg.Scaling;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->YIntegral = pbMsg.YIntegral;
    inOutObject->DeviceID = pbMsg.DeviceID;
    inOutObject->Y = pbMsg.Y;
    inOutObject->X = pbMsg.X;
    inOutObject->Z = pbMsg.Z;
    inOutObject->ErrorCount = pbMsg.ErrorCount;
    inOutObject->XRaw = pbMsg.XRaw;
    inOutObject->Temperature = pbMsg.Temperature;

	return sizeof(PX4_SensorAccelMsg_t);
}


uint32 PX4_SensorMagMsg_t_Enc(const PX4_SensorMagMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SensorMagMsg_t_pb pbMsg;

    pbMsg.Temperature = inObject->Temperature;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.ZRaw = inObject->ZRaw;
    pbMsg.YRaw = inObject->YRaw;
    pbMsg.Scaling = inObject->Scaling;
    pbMsg.Range = inObject->Range;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.DeviceID = inObject->DeviceID;
    pbMsg.Y = inObject->Y;
    pbMsg.X = inObject->X;
    pbMsg.Z = inObject->Z;
    pbMsg.ErrorCount = inObject->ErrorCount;
    pbMsg.XRaw = inObject->XRaw;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SensorMagMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SensorMagMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SensorMagMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SensorMagMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SensorMagMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Temperature = pbMsg.Temperature;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->ZRaw = pbMsg.ZRaw;
    inOutObject->YRaw = pbMsg.YRaw;
    inOutObject->Scaling = pbMsg.Scaling;
    inOutObject->Range = pbMsg.Range;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->DeviceID = pbMsg.DeviceID;
    inOutObject->Y = pbMsg.Y;
    inOutObject->X = pbMsg.X;
    inOutObject->Z = pbMsg.Z;
    inOutObject->ErrorCount = pbMsg.ErrorCount;
    inOutObject->XRaw = pbMsg.XRaw;

	return sizeof(PX4_SensorMagMsg_t);
}


uint32 PX4_DifferentialPressureMsg_t_Enc(const PX4_DifferentialPressureMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_DifferentialPressureMsg_t_pb pbMsg;

    pbMsg.DifferentialPressureFiltered = inObject->DifferentialPressureFiltered;
    pbMsg.Temperature = inObject->Temperature;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.ErrorCount = inObject->ErrorCount;
    pbMsg.DifferentialPressureRaw = inObject->DifferentialPressureRaw;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_DifferentialPressureMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_DifferentialPressureMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_DifferentialPressureMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_DifferentialPressureMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_DifferentialPressureMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->DifferentialPressureFiltered = pbMsg.DifferentialPressureFiltered;
    inOutObject->Temperature = pbMsg.Temperature;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->ErrorCount = pbMsg.ErrorCount;
    inOutObject->DifferentialPressureRaw = pbMsg.DifferentialPressureRaw;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];

	return sizeof(PX4_DifferentialPressureMsg_t);
}


uint32 PX4_SensorGyroMsg_t_Enc(const PX4_SensorGyroMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SensorGyroMsg_t_pb pbMsg;

    pbMsg.TemperatureRaw = inObject->TemperatureRaw;
    pbMsg.ZIntegral = inObject->ZIntegral;
    pbMsg.XIntegral = inObject->XIntegral;
    pbMsg.IntegralDt = inObject->IntegralDt;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.ZRaw = inObject->ZRaw;
    pbMsg.YRaw = inObject->YRaw;
    pbMsg.Scaling = inObject->Scaling;
    pbMsg.Range = inObject->Range;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.YIntegral = inObject->YIntegral;
    pbMsg.DeviceID = inObject->DeviceID;
    pbMsg.Y = inObject->Y;
    pbMsg.X = inObject->X;
    pbMsg.Z = inObject->Z;
    pbMsg.ErrorCount = inObject->ErrorCount;
    pbMsg.XRaw = inObject->XRaw;
    pbMsg.Temperature = inObject->Temperature;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SensorGyroMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SensorGyroMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SensorGyroMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SensorGyroMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SensorGyroMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->TemperatureRaw = pbMsg.TemperatureRaw;
    inOutObject->ZIntegral = pbMsg.ZIntegral;
    inOutObject->XIntegral = pbMsg.XIntegral;
    inOutObject->IntegralDt = pbMsg.IntegralDt;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->ZRaw = pbMsg.ZRaw;
    inOutObject->YRaw = pbMsg.YRaw;
    inOutObject->Scaling = pbMsg.Scaling;
    inOutObject->Range = pbMsg.Range;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->YIntegral = pbMsg.YIntegral;
    inOutObject->DeviceID = pbMsg.DeviceID;
    inOutObject->Y = pbMsg.Y;
    inOutObject->X = pbMsg.X;
    inOutObject->Z = pbMsg.Z;
    inOutObject->ErrorCount = pbMsg.ErrorCount;
    inOutObject->XRaw = pbMsg.XRaw;
    inOutObject->Temperature = pbMsg.Temperature;

	return sizeof(PX4_SensorGyroMsg_t);
}




uint32 PX4_ActuatorArmedMsg_t_Enc(const PX4_ActuatorArmedMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_ActuatorArmedMsg_t_pb pbMsg;

    pbMsg.ForceFailsafe = inObject->ForceFailsafe;
    pbMsg.ReadyToArm = inObject->ReadyToArm;
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.InEscCalibrationMode = inObject->InEscCalibrationMode;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.Lockdown = inObject->Lockdown;
    pbMsg.Prearmed = inObject->Prearmed;
    pbMsg.Armed = inObject->Armed;
    pbMsg.ManualLockdown = inObject->ManualLockdown;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_ActuatorArmedMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_ActuatorArmedMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_ActuatorArmedMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_ActuatorArmedMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_ActuatorArmedMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->ForceFailsafe = pbMsg.ForceFailsafe;
    inOutObject->ReadyToArm = pbMsg.ReadyToArm;
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->InEscCalibrationMode = pbMsg.InEscCalibrationMode;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->Lockdown = pbMsg.Lockdown;
    inOutObject->Prearmed = pbMsg.Prearmed;
    inOutObject->Armed = pbMsg.Armed;
    inOutObject->ManualLockdown = pbMsg.ManualLockdown;

	return sizeof(PX4_ActuatorArmedMsg_t);
}


uint32 PX4_ActuatorOutputsMsg_t_Enc(const PX4_ActuatorOutputsMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_ActuatorOutputsMsg_t_pb pbMsg;

    pbMsg.Count = inObject->Count;
    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    /* Unroll indexes */
    pbMsg.Output_count = 16;
    pbMsg.Output[0] = inObject->Output[0];
    pbMsg.Output[1] = inObject->Output[1];
    pbMsg.Output[2] = inObject->Output[2];
    pbMsg.Output[3] = inObject->Output[3];
    pbMsg.Output[4] = inObject->Output[4];
    pbMsg.Output[5] = inObject->Output[5];
    pbMsg.Output[6] = inObject->Output[6];
    pbMsg.Output[7] = inObject->Output[7];
    pbMsg.Output[8] = inObject->Output[8];
    pbMsg.Output[9] = inObject->Output[9];
    pbMsg.Output[10] = inObject->Output[10];
    pbMsg.Output[11] = inObject->Output[11];
    pbMsg.Output[12] = inObject->Output[12];
    pbMsg.Output[13] = inObject->Output[13];
    pbMsg.Output[14] = inObject->Output[14];
    pbMsg.Output[15] = inObject->Output[15];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_ActuatorOutputsMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_ActuatorOutputsMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_ActuatorOutputsMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_ActuatorOutputsMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_ActuatorOutputsMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Count = pbMsg.Count;
    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    /* Unroll indexes */
    inOutObject->Output[0] = pbMsg.Output[0];
    inOutObject->Output[1] = pbMsg.Output[1];
    inOutObject->Output[2] = pbMsg.Output[2];
    inOutObject->Output[3] = pbMsg.Output[3];
    inOutObject->Output[4] = pbMsg.Output[4];
    inOutObject->Output[5] = pbMsg.Output[5];
    inOutObject->Output[6] = pbMsg.Output[6];
    inOutObject->Output[7] = pbMsg.Output[7];
    inOutObject->Output[8] = pbMsg.Output[8];
    inOutObject->Output[9] = pbMsg.Output[9];
    inOutObject->Output[10] = pbMsg.Output[10];
    inOutObject->Output[11] = pbMsg.Output[11];
    inOutObject->Output[12] = pbMsg.Output[12];
    inOutObject->Output[13] = pbMsg.Output[13];
    inOutObject->Output[14] = pbMsg.Output[14];
    inOutObject->Output[15] = pbMsg.Output[15];

	return sizeof(PX4_ActuatorOutputsMsg_t);
}


uint32 PX4_SensorCorrectionMsg_t_Enc(const PX4_SensorCorrectionMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SensorCorrectionMsg_t_pb pbMsg;

    pbMsg.selected_gyro_instance = inObject->selected_gyro_instance;
    /* Unroll indexes */
    pbMsg.baro_mapping_count = 3;
    pbMsg.baro_mapping[0] = inObject->baro_mapping[0];
    pbMsg.baro_mapping[1] = inObject->baro_mapping[1];
    pbMsg.baro_mapping[2] = inObject->baro_mapping[2];
    /* Unroll indexes */
    pbMsg.accel_offset_0_count = 3;
    pbMsg.accel_offset_0[0] = inObject->accel_offset_0[0];
    pbMsg.accel_offset_0[1] = inObject->accel_offset_0[1];
    pbMsg.accel_offset_0[2] = inObject->accel_offset_0[2];
    /* Unroll indexes */
    pbMsg.gyro_offset_1_count = 3;
    pbMsg.gyro_offset_1[0] = inObject->gyro_offset_1[0];
    pbMsg.gyro_offset_1[1] = inObject->gyro_offset_1[1];
    pbMsg.gyro_offset_1[2] = inObject->gyro_offset_1[2];
    /* Unroll indexes */
    pbMsg.gyro_offset_0_count = 3;
    pbMsg.gyro_offset_0[0] = inObject->gyro_offset_0[0];
    pbMsg.gyro_offset_0[1] = inObject->gyro_offset_0[1];
    pbMsg.gyro_offset_0[2] = inObject->gyro_offset_0[2];
    pbMsg.baro_scale_2 = inObject->baro_scale_2;
    /* Unroll indexes */
    pbMsg.gyro_offset_2_count = 3;
    pbMsg.gyro_offset_2[0] = inObject->gyro_offset_2[0];
    pbMsg.gyro_offset_2[1] = inObject->gyro_offset_2[1];
    pbMsg.gyro_offset_2[2] = inObject->gyro_offset_2[2];
    /* Unroll indexes */
    pbMsg.accel_scale_2_count = 3;
    pbMsg.accel_scale_2[0] = inObject->accel_scale_2[0];
    pbMsg.accel_scale_2[1] = inObject->accel_scale_2[1];
    pbMsg.accel_scale_2[2] = inObject->accel_scale_2[2];
    /* Unroll indexes */
    pbMsg.accel_scale_1_count = 3;
    pbMsg.accel_scale_1[0] = inObject->accel_scale_1[0];
    pbMsg.accel_scale_1[1] = inObject->accel_scale_1[1];
    pbMsg.accel_scale_1[2] = inObject->accel_scale_1[2];
    /* Unroll indexes */
    pbMsg.accel_scale_0_count = 3;
    pbMsg.accel_scale_0[0] = inObject->accel_scale_0[0];
    pbMsg.accel_scale_0[1] = inObject->accel_scale_0[1];
    pbMsg.accel_scale_0[2] = inObject->accel_scale_0[2];
    pbMsg.Timestamp = inObject->Timestamp;
    pbMsg.selected_baro_instance = inObject->selected_baro_instance;
    pbMsg.baro_offset_0 = inObject->baro_offset_0;
    pbMsg.baro_offset_1 = inObject->baro_offset_1;
    pbMsg.baro_offset_2 = inObject->baro_offset_2;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.baro_scale_0 = inObject->baro_scale_0;
    pbMsg.baro_scale_1 = inObject->baro_scale_1;
    /* Unroll indexes */
    pbMsg.accel_offset_2_count = 3;
    pbMsg.accel_offset_2[0] = inObject->accel_offset_2[0];
    pbMsg.accel_offset_2[1] = inObject->accel_offset_2[1];
    pbMsg.accel_offset_2[2] = inObject->accel_offset_2[2];
    pbMsg.selected_accel_instance = inObject->selected_accel_instance;
    /* Unroll indexes */
    pbMsg.accel_mapping_count = 3;
    pbMsg.accel_mapping[0] = inObject->accel_mapping[0];
    pbMsg.accel_mapping[1] = inObject->accel_mapping[1];
    pbMsg.accel_mapping[2] = inObject->accel_mapping[2];
    /* Unroll indexes */
    pbMsg.gyro_mapping_count = 3;
    pbMsg.gyro_mapping[0] = inObject->gyro_mapping[0];
    pbMsg.gyro_mapping[1] = inObject->gyro_mapping[1];
    pbMsg.gyro_mapping[2] = inObject->gyro_mapping[2];
    /* Unroll indexes */
    pbMsg.gyro_scale_2_count = 3;
    pbMsg.gyro_scale_2[0] = inObject->gyro_scale_2[0];
    pbMsg.gyro_scale_2[1] = inObject->gyro_scale_2[1];
    pbMsg.gyro_scale_2[2] = inObject->gyro_scale_2[2];
    /* Unroll indexes */
    pbMsg.gyro_scale_1_count = 3;
    pbMsg.gyro_scale_1[0] = inObject->gyro_scale_1[0];
    pbMsg.gyro_scale_1[1] = inObject->gyro_scale_1[1];
    pbMsg.gyro_scale_1[2] = inObject->gyro_scale_1[2];
    /* Unroll indexes */
    pbMsg.gyro_scale_0_count = 3;
    pbMsg.gyro_scale_0[0] = inObject->gyro_scale_0[0];
    pbMsg.gyro_scale_0[1] = inObject->gyro_scale_0[1];
    pbMsg.gyro_scale_0[2] = inObject->gyro_scale_0[2];
    /* Unroll indexes */
    pbMsg.accel_offset_1_count = 3;
    pbMsg.accel_offset_1[0] = inObject->accel_offset_1[0];
    pbMsg.accel_offset_1[1] = inObject->accel_offset_1[1];
    pbMsg.accel_offset_1[2] = inObject->accel_offset_1[2];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SensorCorrectionMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SensorCorrectionMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SensorCorrectionMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SensorCorrectionMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SensorCorrectionMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->selected_gyro_instance = pbMsg.selected_gyro_instance;
    /* Unroll indexes */
    inOutObject->baro_mapping[0] = pbMsg.baro_mapping[0];
    inOutObject->baro_mapping[1] = pbMsg.baro_mapping[1];
    inOutObject->baro_mapping[2] = pbMsg.baro_mapping[2];
    /* Unroll indexes */
    inOutObject->accel_offset_0[0] = pbMsg.accel_offset_0[0];
    inOutObject->accel_offset_0[1] = pbMsg.accel_offset_0[1];
    inOutObject->accel_offset_0[2] = pbMsg.accel_offset_0[2];
    /* Unroll indexes */
    inOutObject->gyro_offset_1[0] = pbMsg.gyro_offset_1[0];
    inOutObject->gyro_offset_1[1] = pbMsg.gyro_offset_1[1];
    inOutObject->gyro_offset_1[2] = pbMsg.gyro_offset_1[2];
    /* Unroll indexes */
    inOutObject->gyro_offset_0[0] = pbMsg.gyro_offset_0[0];
    inOutObject->gyro_offset_0[1] = pbMsg.gyro_offset_0[1];
    inOutObject->gyro_offset_0[2] = pbMsg.gyro_offset_0[2];
    inOutObject->baro_scale_2 = pbMsg.baro_scale_2;
    /* Unroll indexes */
    inOutObject->gyro_offset_2[0] = pbMsg.gyro_offset_2[0];
    inOutObject->gyro_offset_2[1] = pbMsg.gyro_offset_2[1];
    inOutObject->gyro_offset_2[2] = pbMsg.gyro_offset_2[2];
    /* Unroll indexes */
    inOutObject->accel_scale_2[0] = pbMsg.accel_scale_2[0];
    inOutObject->accel_scale_2[1] = pbMsg.accel_scale_2[1];
    inOutObject->accel_scale_2[2] = pbMsg.accel_scale_2[2];
    /* Unroll indexes */
    inOutObject->accel_scale_1[0] = pbMsg.accel_scale_1[0];
    inOutObject->accel_scale_1[1] = pbMsg.accel_scale_1[1];
    inOutObject->accel_scale_1[2] = pbMsg.accel_scale_1[2];
    /* Unroll indexes */
    inOutObject->accel_scale_0[0] = pbMsg.accel_scale_0[0];
    inOutObject->accel_scale_0[1] = pbMsg.accel_scale_0[1];
    inOutObject->accel_scale_0[2] = pbMsg.accel_scale_0[2];
    inOutObject->Timestamp = pbMsg.Timestamp;
    inOutObject->selected_baro_instance = pbMsg.selected_baro_instance;
    inOutObject->baro_offset_0 = pbMsg.baro_offset_0;
    inOutObject->baro_offset_1 = pbMsg.baro_offset_1;
    inOutObject->baro_offset_2 = pbMsg.baro_offset_2;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->baro_scale_0 = pbMsg.baro_scale_0;
    inOutObject->baro_scale_1 = pbMsg.baro_scale_1;
    /* Unroll indexes */
    inOutObject->accel_offset_2[0] = pbMsg.accel_offset_2[0];
    inOutObject->accel_offset_2[1] = pbMsg.accel_offset_2[1];
    inOutObject->accel_offset_2[2] = pbMsg.accel_offset_2[2];
    inOutObject->selected_accel_instance = pbMsg.selected_accel_instance;
    /* Unroll indexes */
    inOutObject->accel_mapping[0] = pbMsg.accel_mapping[0];
    inOutObject->accel_mapping[1] = pbMsg.accel_mapping[1];
    inOutObject->accel_mapping[2] = pbMsg.accel_mapping[2];
    /* Unroll indexes */
    inOutObject->gyro_mapping[0] = pbMsg.gyro_mapping[0];
    inOutObject->gyro_mapping[1] = pbMsg.gyro_mapping[1];
    inOutObject->gyro_mapping[2] = pbMsg.gyro_mapping[2];
    /* Unroll indexes */
    inOutObject->gyro_scale_2[0] = pbMsg.gyro_scale_2[0];
    inOutObject->gyro_scale_2[1] = pbMsg.gyro_scale_2[1];
    inOutObject->gyro_scale_2[2] = pbMsg.gyro_scale_2[2];
    /* Unroll indexes */
    inOutObject->gyro_scale_1[0] = pbMsg.gyro_scale_1[0];
    inOutObject->gyro_scale_1[1] = pbMsg.gyro_scale_1[1];
    inOutObject->gyro_scale_1[2] = pbMsg.gyro_scale_1[2];
    /* Unroll indexes */
    inOutObject->gyro_scale_0[0] = pbMsg.gyro_scale_0[0];
    inOutObject->gyro_scale_0[1] = pbMsg.gyro_scale_0[1];
    inOutObject->gyro_scale_0[2] = pbMsg.gyro_scale_0[2];
    /* Unroll indexes */
    inOutObject->accel_offset_1[0] = pbMsg.accel_offset_1[0];
    inOutObject->accel_offset_1[1] = pbMsg.accel_offset_1[1];
    inOutObject->accel_offset_1[2] = pbMsg.accel_offset_1[2];

	return sizeof(PX4_SensorCorrectionMsg_t);
}


uint32 PX4_CommanderStateMsg_t_Enc(const PX4_CommanderStateMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_CommanderStateMsg_t_pb pbMsg;

    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    pbMsg.MainState = inObject->MainState;

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_CommanderStateMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_CommanderStateMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_CommanderStateMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_CommanderStateMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_CommanderStateMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    inOutObject->MainState = pbMsg.MainState;

	return sizeof(PX4_CommanderStateMsg_t);
}


uint32 PX4_SatelliteInfoMsg_t_Enc(const PX4_SatelliteInfoMsg_t *inObject, char *inOutBuffer, uint32 inSize)
{
	bool status = false;
	pb_ostream_t stream;

	PX4_SatelliteInfoMsg_t_pb pbMsg;

    pbMsg.Count = inObject->Count;
    /* Unroll indexes */
    pbMsg.Used_count = 20;
    pbMsg.Used[0] = inObject->Used[0];
    pbMsg.Used[1] = inObject->Used[1];
    pbMsg.Used[2] = inObject->Used[2];
    pbMsg.Used[3] = inObject->Used[3];
    pbMsg.Used[4] = inObject->Used[4];
    pbMsg.Used[5] = inObject->Used[5];
    pbMsg.Used[6] = inObject->Used[6];
    pbMsg.Used[7] = inObject->Used[7];
    pbMsg.Used[8] = inObject->Used[8];
    pbMsg.Used[9] = inObject->Used[9];
    pbMsg.Used[10] = inObject->Used[10];
    pbMsg.Used[11] = inObject->Used[11];
    pbMsg.Used[12] = inObject->Used[12];
    pbMsg.Used[13] = inObject->Used[13];
    pbMsg.Used[14] = inObject->Used[14];
    pbMsg.Used[15] = inObject->Used[15];
    pbMsg.Used[16] = inObject->Used[16];
    pbMsg.Used[17] = inObject->Used[17];
    pbMsg.Used[18] = inObject->Used[18];
    pbMsg.Used[19] = inObject->Used[19];
    /* Unroll indexes */
    pbMsg.Elevation_count = 20;
    pbMsg.Elevation[0] = inObject->Elevation[0];
    pbMsg.Elevation[1] = inObject->Elevation[1];
    pbMsg.Elevation[2] = inObject->Elevation[2];
    pbMsg.Elevation[3] = inObject->Elevation[3];
    pbMsg.Elevation[4] = inObject->Elevation[4];
    pbMsg.Elevation[5] = inObject->Elevation[5];
    pbMsg.Elevation[6] = inObject->Elevation[6];
    pbMsg.Elevation[7] = inObject->Elevation[7];
    pbMsg.Elevation[8] = inObject->Elevation[8];
    pbMsg.Elevation[9] = inObject->Elevation[9];
    pbMsg.Elevation[10] = inObject->Elevation[10];
    pbMsg.Elevation[11] = inObject->Elevation[11];
    pbMsg.Elevation[12] = inObject->Elevation[12];
    pbMsg.Elevation[13] = inObject->Elevation[13];
    pbMsg.Elevation[14] = inObject->Elevation[14];
    pbMsg.Elevation[15] = inObject->Elevation[15];
    pbMsg.Elevation[16] = inObject->Elevation[16];
    pbMsg.Elevation[17] = inObject->Elevation[17];
    pbMsg.Elevation[18] = inObject->Elevation[18];
    pbMsg.Elevation[19] = inObject->Elevation[19];
    pbMsg.Timestamp = inObject->Timestamp;
    /* Unroll indexes */
    pbMsg.SVID_count = 20;
    pbMsg.SVID[0] = inObject->SVID[0];
    pbMsg.SVID[1] = inObject->SVID[1];
    pbMsg.SVID[2] = inObject->SVID[2];
    pbMsg.SVID[3] = inObject->SVID[3];
    pbMsg.SVID[4] = inObject->SVID[4];
    pbMsg.SVID[5] = inObject->SVID[5];
    pbMsg.SVID[6] = inObject->SVID[6];
    pbMsg.SVID[7] = inObject->SVID[7];
    pbMsg.SVID[8] = inObject->SVID[8];
    pbMsg.SVID[9] = inObject->SVID[9];
    pbMsg.SVID[10] = inObject->SVID[10];
    pbMsg.SVID[11] = inObject->SVID[11];
    pbMsg.SVID[12] = inObject->SVID[12];
    pbMsg.SVID[13] = inObject->SVID[13];
    pbMsg.SVID[14] = inObject->SVID[14];
    pbMsg.SVID[15] = inObject->SVID[15];
    pbMsg.SVID[16] = inObject->SVID[16];
    pbMsg.SVID[17] = inObject->SVID[17];
    pbMsg.SVID[18] = inObject->SVID[18];
    pbMsg.SVID[19] = inObject->SVID[19];
    /* Unroll indexes */
    pbMsg.TlmHeader_count = 12;
    pbMsg.TlmHeader[0] = inObject->TlmHeader[0];
    pbMsg.TlmHeader[1] = inObject->TlmHeader[1];
    pbMsg.TlmHeader[2] = inObject->TlmHeader[2];
    pbMsg.TlmHeader[3] = inObject->TlmHeader[3];
    pbMsg.TlmHeader[4] = inObject->TlmHeader[4];
    pbMsg.TlmHeader[5] = inObject->TlmHeader[5];
    pbMsg.TlmHeader[6] = inObject->TlmHeader[6];
    pbMsg.TlmHeader[7] = inObject->TlmHeader[7];
    pbMsg.TlmHeader[8] = inObject->TlmHeader[8];
    pbMsg.TlmHeader[9] = inObject->TlmHeader[9];
    pbMsg.TlmHeader[10] = inObject->TlmHeader[10];
    pbMsg.TlmHeader[11] = inObject->TlmHeader[11];
    /* Unroll indexes */
    pbMsg.SNR_count = 20;
    pbMsg.SNR[0] = inObject->SNR[0];
    pbMsg.SNR[1] = inObject->SNR[1];
    pbMsg.SNR[2] = inObject->SNR[2];
    pbMsg.SNR[3] = inObject->SNR[3];
    pbMsg.SNR[4] = inObject->SNR[4];
    pbMsg.SNR[5] = inObject->SNR[5];
    pbMsg.SNR[6] = inObject->SNR[6];
    pbMsg.SNR[7] = inObject->SNR[7];
    pbMsg.SNR[8] = inObject->SNR[8];
    pbMsg.SNR[9] = inObject->SNR[9];
    pbMsg.SNR[10] = inObject->SNR[10];
    pbMsg.SNR[11] = inObject->SNR[11];
    pbMsg.SNR[12] = inObject->SNR[12];
    pbMsg.SNR[13] = inObject->SNR[13];
    pbMsg.SNR[14] = inObject->SNR[14];
    pbMsg.SNR[15] = inObject->SNR[15];
    pbMsg.SNR[16] = inObject->SNR[16];
    pbMsg.SNR[17] = inObject->SNR[17];
    pbMsg.SNR[18] = inObject->SNR[18];
    pbMsg.SNR[19] = inObject->SNR[19];
    /* Unroll indexes */
    pbMsg.Azimuth_count = 20;
    pbMsg.Azimuth[0] = inObject->Azimuth[0];
    pbMsg.Azimuth[1] = inObject->Azimuth[1];
    pbMsg.Azimuth[2] = inObject->Azimuth[2];
    pbMsg.Azimuth[3] = inObject->Azimuth[3];
    pbMsg.Azimuth[4] = inObject->Azimuth[4];
    pbMsg.Azimuth[5] = inObject->Azimuth[5];
    pbMsg.Azimuth[6] = inObject->Azimuth[6];
    pbMsg.Azimuth[7] = inObject->Azimuth[7];
    pbMsg.Azimuth[8] = inObject->Azimuth[8];
    pbMsg.Azimuth[9] = inObject->Azimuth[9];
    pbMsg.Azimuth[10] = inObject->Azimuth[10];
    pbMsg.Azimuth[11] = inObject->Azimuth[11];
    pbMsg.Azimuth[12] = inObject->Azimuth[12];
    pbMsg.Azimuth[13] = inObject->Azimuth[13];
    pbMsg.Azimuth[14] = inObject->Azimuth[14];
    pbMsg.Azimuth[15] = inObject->Azimuth[15];
    pbMsg.Azimuth[16] = inObject->Azimuth[16];
    pbMsg.Azimuth[17] = inObject->Azimuth[17];
    pbMsg.Azimuth[18] = inObject->Azimuth[18];
    pbMsg.Azimuth[19] = inObject->Azimuth[19];

	/* Create a stream that will write to our buffer. */
	stream = pb_ostream_from_buffer((pb_byte_t *)inOutBuffer, inSize);
	
	/* Now we are ready to encode the message. */
	status = pb_encode(&stream, PX4_SatelliteInfoMsg_t_pb_fields, &pbMsg);

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error encoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

	return stream.bytes_written;
}

uint32 PX4_SatelliteInfoMsg_t_Dec(const char *inBuffer, uint32 inSize, PX4_SatelliteInfoMsg_t *inOutObject)
{
	bool status = false;
	pb_istream_t stream;

	PX4_SatelliteInfoMsg_t_pb pbMsg;

    /* Create a stream that reads from the buffer. */
	stream = pb_istream_from_buffer((const pb_byte_t *)inBuffer, inSize);

	/* Now we are ready to decode the message. */
	status = pb_decode(&stream, PX4_SatelliteInfoMsg_t_pb_fields, &pbMsg); 

	/* Check for errors... */
	if (!status)
	{
        OS_printf("Error decoding msg: %s", PB_GET_ERROR(&stream));
		return 0;
	}

    inOutObject->Count = pbMsg.Count;
    /* Unroll indexes */
    inOutObject->Used[0] = pbMsg.Used[0];
    inOutObject->Used[1] = pbMsg.Used[1];
    inOutObject->Used[2] = pbMsg.Used[2];
    inOutObject->Used[3] = pbMsg.Used[3];
    inOutObject->Used[4] = pbMsg.Used[4];
    inOutObject->Used[5] = pbMsg.Used[5];
    inOutObject->Used[6] = pbMsg.Used[6];
    inOutObject->Used[7] = pbMsg.Used[7];
    inOutObject->Used[8] = pbMsg.Used[8];
    inOutObject->Used[9] = pbMsg.Used[9];
    inOutObject->Used[10] = pbMsg.Used[10];
    inOutObject->Used[11] = pbMsg.Used[11];
    inOutObject->Used[12] = pbMsg.Used[12];
    inOutObject->Used[13] = pbMsg.Used[13];
    inOutObject->Used[14] = pbMsg.Used[14];
    inOutObject->Used[15] = pbMsg.Used[15];
    inOutObject->Used[16] = pbMsg.Used[16];
    inOutObject->Used[17] = pbMsg.Used[17];
    inOutObject->Used[18] = pbMsg.Used[18];
    inOutObject->Used[19] = pbMsg.Used[19];
    /* Unroll indexes */
    inOutObject->Elevation[0] = pbMsg.Elevation[0];
    inOutObject->Elevation[1] = pbMsg.Elevation[1];
    inOutObject->Elevation[2] = pbMsg.Elevation[2];
    inOutObject->Elevation[3] = pbMsg.Elevation[3];
    inOutObject->Elevation[4] = pbMsg.Elevation[4];
    inOutObject->Elevation[5] = pbMsg.Elevation[5];
    inOutObject->Elevation[6] = pbMsg.Elevation[6];
    inOutObject->Elevation[7] = pbMsg.Elevation[7];
    inOutObject->Elevation[8] = pbMsg.Elevation[8];
    inOutObject->Elevation[9] = pbMsg.Elevation[9];
    inOutObject->Elevation[10] = pbMsg.Elevation[10];
    inOutObject->Elevation[11] = pbMsg.Elevation[11];
    inOutObject->Elevation[12] = pbMsg.Elevation[12];
    inOutObject->Elevation[13] = pbMsg.Elevation[13];
    inOutObject->Elevation[14] = pbMsg.Elevation[14];
    inOutObject->Elevation[15] = pbMsg.Elevation[15];
    inOutObject->Elevation[16] = pbMsg.Elevation[16];
    inOutObject->Elevation[17] = pbMsg.Elevation[17];
    inOutObject->Elevation[18] = pbMsg.Elevation[18];
    inOutObject->Elevation[19] = pbMsg.Elevation[19];
    inOutObject->Timestamp = pbMsg.Timestamp;
    /* Unroll indexes */
    inOutObject->SVID[0] = pbMsg.SVID[0];
    inOutObject->SVID[1] = pbMsg.SVID[1];
    inOutObject->SVID[2] = pbMsg.SVID[2];
    inOutObject->SVID[3] = pbMsg.SVID[3];
    inOutObject->SVID[4] = pbMsg.SVID[4];
    inOutObject->SVID[5] = pbMsg.SVID[5];
    inOutObject->SVID[6] = pbMsg.SVID[6];
    inOutObject->SVID[7] = pbMsg.SVID[7];
    inOutObject->SVID[8] = pbMsg.SVID[8];
    inOutObject->SVID[9] = pbMsg.SVID[9];
    inOutObject->SVID[10] = pbMsg.SVID[10];
    inOutObject->SVID[11] = pbMsg.SVID[11];
    inOutObject->SVID[12] = pbMsg.SVID[12];
    inOutObject->SVID[13] = pbMsg.SVID[13];
    inOutObject->SVID[14] = pbMsg.SVID[14];
    inOutObject->SVID[15] = pbMsg.SVID[15];
    inOutObject->SVID[16] = pbMsg.SVID[16];
    inOutObject->SVID[17] = pbMsg.SVID[17];
    inOutObject->SVID[18] = pbMsg.SVID[18];
    inOutObject->SVID[19] = pbMsg.SVID[19];
    /* Unroll indexes */
    inOutObject->TlmHeader[0] = pbMsg.TlmHeader[0];
    inOutObject->TlmHeader[1] = pbMsg.TlmHeader[1];
    inOutObject->TlmHeader[2] = pbMsg.TlmHeader[2];
    inOutObject->TlmHeader[3] = pbMsg.TlmHeader[3];
    inOutObject->TlmHeader[4] = pbMsg.TlmHeader[4];
    inOutObject->TlmHeader[5] = pbMsg.TlmHeader[5];
    inOutObject->TlmHeader[6] = pbMsg.TlmHeader[6];
    inOutObject->TlmHeader[7] = pbMsg.TlmHeader[7];
    inOutObject->TlmHeader[8] = pbMsg.TlmHeader[8];
    inOutObject->TlmHeader[9] = pbMsg.TlmHeader[9];
    inOutObject->TlmHeader[10] = pbMsg.TlmHeader[10];
    inOutObject->TlmHeader[11] = pbMsg.TlmHeader[11];
    /* Unroll indexes */
    inOutObject->SNR[0] = pbMsg.SNR[0];
    inOutObject->SNR[1] = pbMsg.SNR[1];
    inOutObject->SNR[2] = pbMsg.SNR[2];
    inOutObject->SNR[3] = pbMsg.SNR[3];
    inOutObject->SNR[4] = pbMsg.SNR[4];
    inOutObject->SNR[5] = pbMsg.SNR[5];
    inOutObject->SNR[6] = pbMsg.SNR[6];
    inOutObject->SNR[7] = pbMsg.SNR[7];
    inOutObject->SNR[8] = pbMsg.SNR[8];
    inOutObject->SNR[9] = pbMsg.SNR[9];
    inOutObject->SNR[10] = pbMsg.SNR[10];
    inOutObject->SNR[11] = pbMsg.SNR[11];
    inOutObject->SNR[12] = pbMsg.SNR[12];
    inOutObject->SNR[13] = pbMsg.SNR[13];
    inOutObject->SNR[14] = pbMsg.SNR[14];
    inOutObject->SNR[15] = pbMsg.SNR[15];
    inOutObject->SNR[16] = pbMsg.SNR[16];
    inOutObject->SNR[17] = pbMsg.SNR[17];
    inOutObject->SNR[18] = pbMsg.SNR[18];
    inOutObject->SNR[19] = pbMsg.SNR[19];
    /* Unroll indexes */
    inOutObject->Azimuth[0] = pbMsg.Azimuth[0];
    inOutObject->Azimuth[1] = pbMsg.Azimuth[1];
    inOutObject->Azimuth[2] = pbMsg.Azimuth[2];
    inOutObject->Azimuth[3] = pbMsg.Azimuth[3];
    inOutObject->Azimuth[4] = pbMsg.Azimuth[4];
    inOutObject->Azimuth[5] = pbMsg.Azimuth[5];
    inOutObject->Azimuth[6] = pbMsg.Azimuth[6];
    inOutObject->Azimuth[7] = pbMsg.Azimuth[7];
    inOutObject->Azimuth[8] = pbMsg.Azimuth[8];
    inOutObject->Azimuth[9] = pbMsg.Azimuth[9];
    inOutObject->Azimuth[10] = pbMsg.Azimuth[10];
    inOutObject->Azimuth[11] = pbMsg.Azimuth[11];
    inOutObject->Azimuth[12] = pbMsg.Azimuth[12];
    inOutObject->Azimuth[13] = pbMsg.Azimuth[13];
    inOutObject->Azimuth[14] = pbMsg.Azimuth[14];
    inOutObject->Azimuth[15] = pbMsg.Azimuth[15];
    inOutObject->Azimuth[16] = pbMsg.Azimuth[16];
    inOutObject->Azimuth[17] = pbMsg.Azimuth[17];
    inOutObject->Azimuth[18] = pbMsg.Azimuth[18];
    inOutObject->Azimuth[19] = pbMsg.Azimuth[19];

	return sizeof(PX4_SatelliteInfoMsg_t);
}


#ifdef __cplusplus
} /* extern "C" */
#endif
